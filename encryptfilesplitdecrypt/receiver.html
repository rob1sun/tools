<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Säker Filöverföring (Mottagare v2.1)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; color: #1c1e21; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; } main { background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); width: 100%; max-width: 700px; padding: 2rem; } h1, h2 { border-bottom: 2px solid #28a745; padding-bottom: 10px; margin-top: 0; color: #218838; } h2 { margin-top: 2rem; border-bottom-width: 1px; } .section { margin-bottom: 2rem; } label { display: block; font-weight: 600; margin-bottom: 8px; } input[type="password"], input[type="text"] { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; } input[type="file"] { margin-top: 5px; } button { background-color: #28a745; color: white; border: none; padding: 12px 20px; border-radius: 5px; cursor: pointer; font-size: 1rem; font-weight: 500; transition: background-color 0.2s; margin-top: 10px; } button:hover { background-color: #218838; } button:disabled { background-color: #a0c7ef; cursor: not-allowed; } .drop-zone { border: 2px dashed #ccc; border-radius: 8px; padding: 25px; text-align: center; color: #6c757d; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; margin-top: 1rem; } .drop-zone.dragover { border-color: #28a745; background-color: #f0fff0; } .drop-zone input[type="file"] { display: none; } .status { margin-top: 15px; padding: 10px; border-radius: 5px; text-align: center; font-weight: 500; } .status.success { background-color: #d4edda; color: #155724; } .status.error { background-color: #f8d7da; color: #721c24; } .status.info { background-color: #cce5ff; color: #004085; } .important-note { color: #dc3545; font-weight: bold; } #forget-key-btn { background-color: #dc3545; font-size: 0.8rem; padding: 5px 10px; margin-top: 0; float: right; }
    </style>
</head>
<body>
    <main>
        <h1>Mottagare: Sätt Ihop & Dekryptera</h1>
        <p>Verktyget sätter ihop och dekrypterar fildelar med din säkert lagrade privata nyckel.</p>
        
        <div id="import-section" class="section">
            <h2>Förstagångs-Setup: Importera Privat Nyckel</h2>
            <p>Importera din lösenordsskyddade nyckelfil en gång. Den sparas sedan säkert i din webbläsare för framtida bruk.</p>
            <label for="private-key-file-import">Ladda upp din <span class="important-note">skyddade</span> privata nyckelfil (`.enc.jwk`):</label>
            <input type="file" id="private-key-file-import" accept=".enc.jwk">
            <button id="import-key-btn">Importera och spara nyckel</button>
        </div>

        <div id="unlock-section" class="section" style="display: none;">
            <h2>1. Lås upp din Privata Nyckel <button id="forget-key-btn">Glöm nyckel</button></h2>
            <p>En skyddad privat nyckel finns sparad i din webbläsare. Ange lösenordet för att låsa upp den.</p>
            <label for="private-key-password">Ange lösenordet för nyckeln:</label>
            <input type="password" id="private-key-password" placeholder="Skriv in ditt lösenord..." autocomplete="current-password">
        </div>

        <div class="section">
            <h2>2. Ladda upp Fildelar</h2>
            <div id="decrypt-drop-zone" class="drop-zone">
                <p>Dra och släpp alla fildelar hit, eller klicka för att välja filer</p>
                <input type="file" id="file-parts-input" multiple>
            </div>
            <button id="decrypt-btn">Sätt Ihop & Dekryptera</button>
        </div>
        <div id="status-container" class="status" style="display:none;"></div>
    </main>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- GRÄNSSNITTSELEMENT ---
        const importSection = document.getElementById('import-section');
        const unlockSection = document.getElementById('unlock-section');
        const privateKeyFileInput = document.getElementById('private-key-file-import');
        const importKeyBtn = document.getElementById('import-key-btn');
        const forgetKeyBtn = document.getElementById('forget-key-btn');
        const privateKeyPasswordInput = document.getElementById('private-key-password');
        const filePartsInput = document.getElementById('file-parts-input');
        const decryptBtn = document.getElementById('decrypt-btn');
        const decryptDropZone = document.getElementById('decrypt-drop-zone');
        const statusContainer = document.getElementById('status-container');

        // --- KRYPTOKONSTANTER ---
        const ENCRYPTED_KEY_SIZE = 256;
        const IV_SIZE = 12;
        const SALT_SIZE = 16;
        const PBKDF2_ITERATIONS = 100000;
        
        // --- DATABASHANTERING (IndexedDB) ---
        const DB_NAME = 'SecureKeyStorage';
        const STORE_NAME = 'EncryptedKeys';
        let db;

        function openDb() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onerror = () => reject("Databas kunde inte öppnas.");
                request.onsuccess = () => { db = request.result; resolve(db); };
                request.onupgradeneeded = e => { e.target.result.createObjectStore(STORE_NAME, { keyPath: 'id' }); };
            });
        }

        function getKeyFromDb() {
            return new Promise((resolve) => {
                if (!db) return resolve(null);
                const transaction = db.transaction(STORE_NAME, 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('userPrivateKey');
                request.onsuccess = () => resolve(request.result ? request.result.keyData : null);
                request.onerror = () => resolve(null);
            });
        }

        function saveKeyToDb(keyData) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.put({ id: 'userPrivateKey', keyData: keyData }).onsuccess = () => resolve();
                transaction.onerror = () => reject("Kunde inte spara nyckeln i databasen.");
            });
        }

        function deleteKeyFromDb() {
            return new Promise((resolve) => {
                const transaction = db.transaction(STORE_NAME, 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                store.delete('userPrivateKey').onsuccess = () => resolve();
            });
        }
        
        // --- UI- OCH HJÄLPFUNKTIONER ---
        const showStatus = (m,t='info') => { statusContainer.textContent=m; statusContainer.className=`status ${t}`; statusContainer.style.display='block'; };
        function setupDropZone(dz, i) { const dt=dz.querySelector('p'); dz.addEventListener('click',()=>i.click()); ['dragover','dragleave','drop'].forEach(evName => { dz.addEventListener(evName, e=>{e.preventDefault();e.stopPropagation();if(evName==='dragover')dz.classList.add('dragover');else dz.classList.remove('dragover');});}); dz.addEventListener('drop', e=>{if(e.dataTransfer.files.length){i.files=e.dataTransfer.files;dt.textContent=`${e.dataTransfer.files.length} fildelar valda.`;showStatus(`${e.dataTransfer.files.length} fildelar valda.`,'info');}}); i.addEventListener('change',e=>{if(e.target.files.length){dt.textContent=`${e.target.files.length} fildelar valda.`;}}); }
        function triggerDownload(b, f) { const u=URL.createObjectURL(b);const a=document.createElement('a');a.style.display='none';a.href=u;a.download=f;document.body.appendChild(a);a.click();URL.revokeObjectURL(u);a.remove(); }
        function getPartNumber(f) { const m=f.match(/-del(\d+)av\d+\.txt$/); return m ? parseInt(m[1], 10) : null; }
        
        async function updateUiState() {
            const storedKey = await getKeyFromDb();
            if (storedKey) {
                importSection.style.display = 'none';
                unlockSection.style.display = 'block';
            } else {
                importSection.style.display = 'block';
                unlockSection.style.display = 'none';
            }
        }

        // --- HUVUDFUNKTIONER ---
        async function importAndStoreKey() {
            if (privateKeyFileInput.files.length === 0) return showStatus('Välj din skyddade privata nyckelfil.', 'error');
            try {
                const keyFile = privateKeyFileInput.files[0];
                const keyBuffer = await keyFile.arrayBuffer();
                await saveKeyToDb(keyBuffer);
                showStatus('Nyckeln har importerats och sparats säkert i webbläsaren!', 'success');
                await updateUiState();
            } catch (error) {
                showStatus(`Kunde inte importera nyckel: ${error.message}`, 'error');
            }
        }

        async function forgetKey() {
            if (confirm("Är du säker på att du vill ta bort den sparade nyckeln från webbläsaren?\nDu kommer behöva importera filen igen nästa gång.")) {
                await deleteKeyFromDb();
                showStatus('Den sparade nyckeln har tagits bort.', 'info');
                privateKeyPasswordInput.value = "";
                await updateUiState();
            }
        }
        
        async function assembleAndDecrypt() {
            const storedKey = await getKeyFromDb();
            if (!storedKey) return showStatus('Ingen privat nyckel är importerad.', 'error');
            if (!privateKeyPasswordInput.value) return showStatus('Ange lösenordet för nyckeln.', 'error');
            if (filePartsInput.files.length === 0) return showStatus('Välj de krypterade fildelarna.', 'error');
            
            try {
                showStatus('Steg 1/3: Låser upp privat nyckel...', 'info');
                decryptBtn.disabled = true;

                const salt = storedKey.slice(0, SALT_SIZE);
                const ivKey = storedKey.slice(SALT_SIZE, SALT_SIZE + IV_SIZE);
                const keyData = storedKey.slice(SALT_SIZE + IV_SIZE);
                const keyMaterial = await crypto.subtle.importKey('raw', new TextEncoder().encode(privateKeyPasswordInput.value), {name:'PBKDF2'}, false, ['deriveKey']);
                const aesKeyForKey = await crypto.subtle.deriveKey({ name:'PBKDF2', salt:salt, iterations:PBKDF2_ITERATIONS, hash:'SHA-256'}, keyMaterial, {name:'AES-GCM',length:256}, true, ['decrypt']);
                const privateKeyBytes = await crypto.subtle.decrypt({ name:'AES-GCM', iv:ivKey }, aesKeyForKey, keyData);
                const privateKeyJwk = JSON.parse(new TextDecoder().decode(privateKeyBytes));
                const rsaPrivateKey = await crypto.subtle.importKey('jwk', privateKeyJwk, {name:'RSA-OAEP',hash:'SHA-256'}, true, ['decrypt']);
                
                showStatus('Steg 2/3: Läser och sorterar fildelar...', 'info');
                let files = Array.from(filePartsInput.files);
                let finalFileName = `dekrypterad-fil-${Date.now()}`;
                if (files.length > 1) {
                     files.sort((a,b)=>{ const pA=getPartNumber(a.name); const pB=getPartNumber(b.name); if(pA===null||pB===null) throw new Error('Ogiltigt filnamn på en av delarna.'); return pA - pB; });
                    const match = files[0].name.match(/^(.*)-del1av\d+\.txt$/);
                    if (match) finalFileName = match[1];
                } else if (files.length === 1) {
                    const match = files[0].name.match(/^(.*)-krypterad\.txt$/);
                    if (match) finalFileName = match[1];
                }
                const fileContents = await Promise.all(files.map(f => f.arrayBuffer()));
                const combinedBuffer = await new Blob(fileContents).arrayBuffer();
                
                showStatus('Steg 3/3: Dekrypterar den sammansatta filen...', 'info');
                if (combinedBuffer.byteLength < ENCRYPTED_KEY_SIZE + IV_SIZE) throw new Error("Den sammansatta filen är för liten.");
                const encryptedAesKey = combinedBuffer.slice(0, ENCRYPTED_KEY_SIZE);
                const ivFile = combinedBuffer.slice(ENCRYPTED_KEY_SIZE, ENCRYPTED_KEY_SIZE + IV_SIZE);
                const ciphertext = combinedBuffer.slice(ENCRYPTED_KEY_SIZE + IV_SIZE);
                const decryptedAesKeyBytes = await crypto.subtle.decrypt({name:'RSA-OAEP'}, rsaPrivateKey, encryptedAesKey);
                const aesKeyForFile = await crypto.subtle.importKey('raw', decryptedAesKeyBytes, {name:'AES-GCM'}, true, ['decrypt']);
                const decryptedBuffer = await crypto.subtle.decrypt({name:'AES-GCM', iv:ivFile}, aesKeyForFile, ciphertext);
                triggerDownload(new Blob([decryptedBuffer]), finalFileName);
                showStatus('Filen har satts ihop, dekrypterats och nedladdning har startat!', 'success');
            } catch (error) { showStatus(`Ett fel uppstod: ${error.message}. Kontrollera lösenord och att alla fildelar är valda.`, 'error'); } 
            finally { decryptBtn.disabled = false; }
        }
        
        // --- INITIERING ---
        (async () => {
            try {
                await openDb();
                await updateUiState();
                setupDropZone(decryptDropZone, filePartsInput);
                importKeyBtn.addEventListener('click', importAndStoreKey);
                forgetKeyBtn.addEventListener('click', forgetKey);
                decryptBtn.addEventListener('click', assembleAndDecrypt);
            } catch (e) {
                showStatus("Ett allvarligt fel uppstod med databasen. Använd en annan webbläsare.", "error");
            }
        })();
    });
    </script>
</body>
</html>
