<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Säker Filöverföring</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; color: #1c1e21; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; } main { background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); width: 100%; max-width: 700px; padding: 2rem; } h1 { border-bottom: 2px solid #007bff; padding-bottom: 10px; margin-top: 0; color: #0056b3; } button { background-color: #007bff; color: white; border: none; padding: 12px 20px; border-radius: 5px; cursor: pointer; font-size: 1rem; font-weight: 500; transition: background-color 0.2s; margin-top: 10px; } button:hover { background-color: #0056b3; } button:disabled { background-color: #a0c7ef; cursor: not-allowed; } .drop-zone { border: 2px dashed #ccc; border-radius: 8px; padding: 25px; text-align: center; color: #6c757d; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; margin-top: 1rem; } .drop-zone.dragover { border-color: #007bff; background-color: #f0f8ff; } .drop-zone input[type="file"] { display: none; } .status { margin-top: 15px; padding: 10px; border-radius: 5px; text-align: center; font-weight: 500; } .status.success { background-color: #d4edda; color: #155724; } .status.error { background-color: #f8d7da; color: #721c24; } .status.info { background-color: #cce5ff; color: #004085; } .offline-section { background-color: #e9ecef; border: 1px solid #ddd; border-radius: 8px; padding: 1rem; margin-top: 1.5rem; font-size: 0.9rem; line-height: 1.5; } .offline-section p { margin-top: 0; } #download-app-btn { background-color: #6c757d; font-size: 0.8rem; padding: 8px 15px; margin-top: 5px; } #download-app-btn:hover { background-color: #5a6268; } .tech-details { font-size: 0.85rem; color: #6c757d; margin-top: -10px; padding-bottom: 10px; }
    </style>
</head>
<body>
    <main>
        <h1>Kryptera & Skicka Fil</h1>
        
        <p>Detta verktyg krypterar din fil så att <strong>endast den avsedda mottagaren med den motsvarande privata nyckeln kan öppna den</strong>. Om den krypterade filen överstiger 20 MB delas den automatiskt upp i mindre delar för att kunna skickas via e-post.</p>
        
        <p class="tech-details">Krypteringsmetod: Hybridkryptering (AES-GCM med en RSA-OAEP-säkrad nyckel).</p>
        <div class="offline-section">
            <p><strong>Viktigt:</strong> Även när du använder detta verktyg direkt på webben sker all bearbetning lokalt i din webbläsare. Din fil laddas aldrig upp till någon server. För att du ska kunna känna dig ännu säkrare kan du ladda ner hela applikationen och köra den helt frånkopplad från internet.</p>
            <button id="download-app-btn">Ladda ner verktyget för offline-användning</button>
        </div>
        
        <div class="section">
            <h2>Ladda upp fil för kryptering</h2>
            <div id="encrypt-drop-zone" class="drop-zone">
                <p>Dra och släpp filen här, eller klicka för att välja fil</p>
                <input type="file" id="file-input">
            </div>
            <button id="encrypt-btn">Kryptera och Dela Upp Fil</button>
        </div>
        <div id="status-container" class="status" style="display:none;"></div>
    </main>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        
        // --- START PUBLIK NYCKEL ---
        // IT-ADMINISTRATÖR: Klistra in mottagarens publika nyckel (i JWK/JSON-format) mellan de två backtick-tecknen (`).
        const publicKeyAsText = `
{
  "alg": "RSA-OAEP-256",
  "e": "AQAB",
  "ext": true,
  "key_ops": [
    "encrypt"
  ],
  "kty": "RSA",
  "n": "7w4qZQF1jTnke_DsAlF0FaMv3g8sBYImXP1H_bUB08sFHyIStC8BWl-m1VyS00bLvZHKtf1BcBsmbEKzikqu073DE3x3Ky8zpJKFaqpJypz5e45eQrT1x6KeR1amwnui36XAIQ-g1sQx0v58MkNInvWqwPtr9ICVj1iTa52Yocr3uczWG2loMg3gVUtwt6J8Cq3pG_qk6GST5ZXshreAXL7i7dWOVZoPUPn-8I7GjhwjnfyZoyNGRgSLYyn1s8NQc96nSJWr7lMspFmoJgyj_hoWLMKyA7FkFK2ZGLeIBIxVdhhdDGYZSyLxESwXflFmoD7CHcQ8dhSsJFIT2MZsXQ"
}
        `;
        // --- SLUT PUBLIK NYCKEL ---

        const statusContainer = document.getElementById('status-container');
        const fileInput = document.getElementById('file-input');
        const encryptBtn = document.getElementById('encrypt-btn');
        const encryptDropZone = document.getElementById('encrypt-drop-zone');
        const downloadAppBtn = document.getElementById('download-app-btn');

        const CHUNK_SIZE_MB = 20;
        const CHUNK_SIZE_BYTES = CHUNK_SIZE_MB * 1024 * 1024;
        const ENCRYPTED_KEY_SIZE = 256;
        const IV_SIZE = 12;

        let hardcodedPublicKeyJwk;

        try {
            hardcodedPublicKeyJwk = JSON.parse(publicKeyAsText.trim());
        } catch (error) {
            const msg = "Internt fel: Den inbäddade publika nyckeln är felaktig. Kontakta den som gav dig detta verktyg.";
            showStatus(msg, 'error');
            encryptBtn.disabled = true;
            encryptDropZone.style.pointerEvents = 'none';
            encryptDropZone.style.opacity = '0.5';
            return;
        }
        
        const showStatus = (m,t='info') => { statusContainer.textContent=m; statusContainer.className=`status ${t}`; statusContainer.style.display='block'; };
        function setupDropZone(dz, i) { const dt=dz.querySelector('p'); dz.addEventListener('click',()=>i.click()); ['dragover','dragleave','drop'].forEach(evName => { dz.addEventListener(evName, e=>{e.preventDefault();e.stopPropagation();if(evName==='dragover')dz.classList.add('dragover');else dz.classList.remove('dragover');});}); dz.addEventListener('drop', e=>{if(e.dataTransfer.files.length){i.files=e.dataTransfer.files;dt.textContent=`Vald fil: ${e.dataTransfer.files[0].name}`;showStatus(`Filen '${e.dataTransfer.files[0].name}' har valts.`,'info');}}); i.addEventListener('change',e=>{if(e.target.files.length){dt.textContent=`Vald fil: ${e.target.files[0].name}`;}}); }
        function triggerDownload(b, f) { const u=URL.createObjectURL(b);const a=document.createElement('a');a.style.display='none';a.href=u;a.download=f;document.body.appendChild(a);a.click();URL.revokeObjectURL(u);a.remove(); }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        async function encryptAndSplit() {
            if (fileInput.files.length === 0) return showStatus('Du måste välja en fil att kryptera.', 'error');
            try {
                showStatus('Steg 1/2: Krypterar filen...', 'info');
                encryptBtn.disabled = true;
                const file = fileInput.files[0];
                const rsaPublicKey = await crypto.subtle.importKey('jwk', hardcodedPublicKeyJwk, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['encrypt']);
                const aesKey = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt']);
                const exportedAesKey = await crypto.subtle.exportKey('raw', aesKey);
                const encryptedAesKey = await crypto.subtle.encrypt({ name: 'RSA-OAEP' }, rsaPublicKey, exportedAesKey);
                const iv = crypto.getRandomValues(new Uint8Array(IV_SIZE));
                const fileBuffer = await file.arrayBuffer();
                const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, aesKey, fileBuffer);
                const encryptedBlob = new Blob([encryptedAesKey, iv, ciphertext]);
                const encryptedBuffer = await encryptedBlob.arrayBuffer();
                showStatus(`Steg 2/2: Bearbetar krypterad fil...`, 'info');
                await sleep(500);
                const totalChunks = Math.ceil(encryptedBuffer.byteLength / CHUNK_SIZE_BYTES);
                const originalFileName = file.name;
                if (totalChunks === 1) {
                    triggerDownload(new Blob([encryptedBuffer]), `${originalFileName}-krypterad.txt`);
                    showStatus('Filen krypterades och sparades som en enda del.', 'success');
                } else {
                    showStatus(`Delar upp i ${totalChunks} bitar om ${CHUNK_SIZE_MB} MB...`, 'info');
                    for (let i = 0; i < totalChunks; i++) {
                        const start = i * CHUNK_SIZE_BYTES;
                        const end = start + CHUNK_SIZE_BYTES;
                        const chunk = encryptedBuffer.slice(start, end);
                        showStatus(`Laddar ner del ${i + 1} av ${totalChunks}...`, 'info');
                        triggerDownload(new Blob([chunk]), `${originalFileName}-del${i + 1}av${totalChunks}.txt`);
                        await sleep(300);
                    }
                    showStatus(`Kryptering klar! Filen delades upp i ${totalChunks} delar.`, 'success');
                }
            } catch (error) { showStatus(`Ett fel uppstod: ${error.message}.`, 'error'); } 
            finally { encryptBtn.disabled = false; }
        }
        function downloadApplication() { const s=document.documentElement.outerHTML;const b=new Blob([s],{type:'text/html'});triggerDownload(b,'saker-filkryptering.html'); }
        setupDropZone(encryptDropZone, fileInput);
        encryptBtn.addEventListener('click', encryptAndSplit);
        downloadAppBtn.addEventListener('click', downloadApplication);
    });
    </script>
</body>
</html>
