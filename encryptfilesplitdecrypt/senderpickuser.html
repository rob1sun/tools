<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Säker Filöverföring (URL-baserad)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f0f2f5; color: #1c1e21; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; } main { background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); width: 100%; max-width: 700px; padding: 2rem; } h1, h2 { border-bottom: 2px solid #007bff; padding-bottom: 10px; margin-top: 0; color: #0056b3; } h2 { margin-top: 2rem; border-bottom-width: 1px; } .section { margin-bottom: 2rem; } select { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; background-color: white; font-size: 1rem; } button { background-color: #007bff; color: white; border: none; padding: 12px 20px; border-radius: 5px; cursor: pointer; font-size: 1rem; font-weight: 500; transition: background-color 0.2s; margin-top: 10px; } button:hover { background-color: #0056b3; } button:disabled { background-color: #a0c7ef; cursor: not-allowed; } .drop-zone { border: 2px dashed #ccc; border-radius: 8px; padding: 25px; text-align: center; color: #6c757d; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; margin-top: 1rem; } .drop-zone.dragover { border-color: #007bff; background-color: #f0f8ff; } .drop-zone input[type="file"] { display: none; } .status { margin-top: 15px; padding: 10px; border-radius: 5px; text-align: center; font-weight: 500; } .status.success { background-color: #d4edda; color: #155724; } .status.error { background-color: #f8d7da; color: #721c24; } .status.info { background-color: #cce5ff; color: #004085; }
    </style>
</head>
<body>
    <main>
        <h1>Kryptera & Skicka Fil</h1>
        <p>Välj en mottagare i listan, ladda upp din fil och klicka på kryptera. Filen delas upp vid behov.</p>
        
        <div class="section">
            <h2>1. Välj Mottagare</h2>
            <label for="recipient-select">Mottagarlistan hämtas från en central källa.</label>
            <select id="recipient-select">
                <option value="">Laddar mottagare...</option>
            </select>
        </div>

        <div class="section">
            <h2>2. Ladda upp Fil för Kryptering</h2>
            <div id="file-drop-zone" class="drop-zone">
                <p>Dra och släpp filen här</p>
                <input type="file" id="file-input">
            </div>
        </div>
        <button id="encrypt-btn" disabled>Välj en mottagare och en fil</button>
        <div id="status-container" class="status" style="display:none;"></div>
    </main>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- START KONFIGURATION ---
        // IT-ADMINISTRATÖR: Ange den fullständiga HTTPS-URL:en till er JSON-fil med mottagare.
        const RECIPIENTS_URL = 'https://tools.robertsundin.se/encryptfilesplitdecrypt/userspublickeys.json';
        // --- SLUT KONFIGURATION ---

        const statusContainer = document.getElementById('status-container');
        const recipientSelect = document.getElementById('recipient-select');
        const fileInput = document.getElementById('file-input');
        const encryptBtn = document.getElementById('encrypt-btn');
        const fileDropZone = document.getElementById('file-drop-zone');

        const CHUNK_SIZE_MB = 20;
        const CHUNK_SIZE_BYTES = CHUNK_SIZE_MB * 1024 * 1024;
        const ENCRYPTED_KEY_SIZE = 256;
        const IV_SIZE = 12;

        let recipientsData = []; // För att lagra den hämtade listan

        const showStatus = (m,t='info') => { statusContainer.textContent=m; statusContainer.className=`status ${t}`; statusContainer.style.display='block'; };
        function setupDropZone(dz, i) { const dt=dz.querySelector('p'); dz.addEventListener('click',()=>i.click()); ['dragover','dragleave','drop'].forEach(evName => { dz.addEventListener(evName, e=>{e.preventDefault();e.stopPropagation();if(evName==='dragover')dz.classList.add('dragover');else dz.classList.remove('dragover');});}); dz.addEventListener('drop', e=>{if(e.dataTransfer.files.length){i.files=e.dataTransfer.files;dt.textContent=`Vald fil: ${e.dataTransfer.files[0].name}`;checkIfReady();}}); i.addEventListener('change',e=>{if(e.target.files.length){dt.textContent=`Vald fil: ${e.target.files[0].name}`;checkIfReady();}}); }
        function triggerDownload(b, f) { const u=URL.createObjectURL(b);const a=document.createElement('a');a.style.display='none';a.href=u;a.download=f;document.body.appendChild(a);a.click();URL.revokeObjectURL(u);a.remove(); }
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        function checkIfReady() {
            if (recipientSelect.value && fileInput.files.length > 0) {
                encryptBtn.disabled = false;
                encryptBtn.textContent = 'Kryptera och Dela Upp Fil';
            } else {
                encryptBtn.disabled = true;
                encryptBtn.textContent = 'Välj en mottagare och en fil';
            }
        }
        
        async function loadRecipients() {
            try {
                const response = await fetch(RECIPIENTS_URL);
                if (!response.ok) throw new Error(`Nätverksfel: ${response.statusText}`);
                recipientsData = await response.json();

                recipientSelect.innerHTML = '<option value="">-- Välj en mottagare --</option>'; // Rensa
                recipientsData.forEach((user, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${user.firstName} ${user.lastName} (${user.email})`;
                    recipientSelect.appendChild(option);
                });
                recipientSelect.disabled = false;
            } catch (error) {
                recipientSelect.innerHTML = '<option value="">Kunde inte ladda mottagare</option>';
                showStatus(`Fel vid hämtning av mottagarlista: ${error.message}. Kontrollera att servern är nåbar och har korrekta CORS-inställningar.`, 'error');
            }
        }

        async function encryptAndSplit() {
            const selectedIndex = recipientSelect.value;
            if (selectedIndex === "") return showStatus('Du måste välja en mottagare.', 'error');
            if (fileInput.files.length === 0) return showStatus('Du måste välja en fil att kryptera.', 'error');
            
            try {
                showStatus('Steg 1/2: Krypterar filen...', 'info');
                encryptBtn.disabled = true;
                const file = fileInput.files[0];
                const publicKeyJwk = recipientsData[selectedIndex].publicKey;

                const rsaPublicKey = await crypto.subtle.importKey('jwk', publicKeyJwk, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['encrypt']);
                const aesKey = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt']);
                const exportedAesKey = await crypto.subtle.exportKey('raw', aesKey);
                const encryptedAesKey = await crypto.subtle.encrypt({ name: 'RSA-OAEP' }, rsaPublicKey, exportedAesKey);
                const iv = crypto.getRandomValues(new Uint8Array(IV_SIZE));
                const fileBuffer = await file.arrayBuffer();
                const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, aesKey, fileBuffer);
                const encryptedBlob = new Blob([encryptedAesKey, iv, ciphertext]);
                const encryptedBuffer = await encryptedBlob.arrayBuffer();
                
                showStatus(`Steg 2/2: Bearbetar krypterad fil...`, 'info');
                await sleep(500);
                const totalChunks = Math.ceil(encryptedBuffer.byteLength / CHUNK_SIZE_BYTES);
                const originalFileName = file.name;
                if (totalChunks === 1) {
                    triggerDownload(new Blob([encryptedBuffer]), `${originalFileName}-krypterad.txt`);
                    showStatus('Filen krypterades och sparades som en enda del.', 'success');
                } else {
                    showStatus(`Delar upp i ${totalChunks} bitar om ${CHUNK_SIZE_MB} MB...`, 'info');
                    for (let i = 0; i < totalChunks; i++) {
                        const start = i * CHUNK_SIZE_BYTES;
                        const end = start + CHUNK_SIZE_BYTES;
                        const chunk = encryptedBuffer.slice(start, end);
                        showStatus(`Laddar ner del ${i + 1} av ${totalChunks}...`, 'info');
                        triggerDownload(new Blob([chunk]), `${originalFileName}-del${i + 1}av${totalChunks}.txt`);
                        await sleep(300);
                    }
                    showStatus(`Kryptering klar! Filen delades upp i ${totalChunks} delar.`, 'success');
                }
            } catch (error) { showStatus(`Ett fel uppstod: ${error.message}.`, 'error'); } 
            finally { checkIfReady(); }
        }

        // --- Initiering ---
        recipientSelect.addEventListener('change', checkIfReady);
        setupDropZone(fileDropZone, fileInput);
        encryptBtn.addEventListener('click', encryptAndSplit);
        loadRecipients();
    });
    </script>
</body>
</html>
