<!-- 
  Bild-till-Musik Sequencer
  En webbapplikation som omvandlar färginnehållet i en bild till en musikalisk sekvens
  med två lager: Harmoni (ackord) och Melodi (enstaka toner).

  Använder:
  - Tailwind CSS (via CDN) för snabb och responsiv styling.
  - Tone.js (via CDN) för all ljudgenerering, syntar och sekvensering.
-->
<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bild-till-Musik Sequencer</title>
    <!-- Ladda Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Ladda Inter-fonten (rekommenderas för modern UI) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Ladda Tone.js för all ljudgenerering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Anpassad CSS för att säkerställa att canvasen fyller sin container och är responsiv */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Mörk bakgrund */
            color: #c9d1d9;
            margin: 0;
            padding: 0;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        canvas {
            border: 2px solid #30363d;
            border-radius: 12px;
            background-color: #161b22;
            touch-action: none; /* Förbättrar hantering på touch-enheter */
        }
        input[type="range"] {
            /* Anpassad stil för reglage */
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #30363d;
            border-radius: 4px;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #58a6ff; /* Blå färg */
            cursor: pointer;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="container">
        <h1 class="text-3xl font-bold text-center text-white mb-4">Bild-till-Musik Sequencer</h1>

        <!-- Status & Bildladdning -->
        <div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
            <p id="statusMessage" class="text-center text-yellow-400 font-semibold mb-4">Laddar ljudmotor. Vänligen vänta...</p>
            
            <div class="flex flex-col sm:flex-row gap-4">
                <input type="file" id="imageLoader" accept="image/*" class="w-full sm:w-1/2 p-2 border border-gray-600 rounded-lg bg-gray-700 text-white cursor-pointer" onchange="handleImage(event)">
                
                <div class="flex w-full sm:w-1/2 gap-4">
                    <button id="startButton" onclick="startSequence()" disabled class="w-1/2 py-2 px-4 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                        Starta Sekvensen
                    </button>
                    <button id="stopButton" onclick="stopSequence()" disabled class="w-1/2 py-2 px-4 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                        Stoppa
                    </button>
                </div>
            </div>
        </div>

        <!-- Rutnät & Tidskontroller -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
            <!-- 1. Yttre Rutnät -->
            <div>
                <label for="outerGridSize" class="block text-sm font-medium mb-1">1. Yttre Rutnät (N x N)</label>
                <input type="number" id="outerGridSize" value="8" min="2" max="32" onchange="redrawGrid()" class="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white">
                <p class="text-xs text-gray-400 mt-1">Styr Harmoni/Ackord.</p>
            </div>
            <!-- 2. Inre Rutnät -->
            <div>
                <label for="innerGridSize" class="block text-sm font-medium mb-1">2. Inre Rutnät (M x M)</label>
                <input type="number" id="innerGridSize" value="4" min="1" max="16" onchange="redrawGrid()" class="w-full p-2 border border-gray-600 rounded-lg bg-gray-700 text-white">
                <p class="text-xs text-gray-400 mt-1">Styr Melodi inuti varje stor ruta.</p>
            </div>
            <!-- 3. Total Tid -->
            <div>
                <label for="sequenceDuration" class="block text-sm font-medium mb-1">3. Total Tid (Minuter)</label>
                <input type="range" id="sequenceDuration" value="1" min="0.1" max="10" step="0.1" oninput="document.getElementById('durationValue').textContent = this.value" class="w-full">
                <p class="text-xs text-gray-400 mt-1">Total tid: <span id="durationValue">1</span> minuter</p>
            </div>
        </div>



        <!-- Känslighetskontroller (Alla 6 reglage) -->
        <div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
            <h2 class="text-xl font-bold mb-4 text-white">Musikalisk Känslighet & Balans</h2>

            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">

                <!-- 4. Yttre Känslighet (Harmoni) -->
                <div>
                    <label for="outerSensitivity" class="block text-sm font-medium mb-1">4. Harmoni (Not/Ackord) Känslighet</label>
                    <input type="range" id="outerSensitivity" value="3.0" min="5.0" max="1.0" step="0.1" oninput="updateSensitivityValue(this, 'outerSensitivityDescription')" onchange="redrawGrid()">
                    <p class="text-xs text-gray-400 mt-1">Variation: <span id="outerSensitivityDescription" class="font-semibold">3.0</span> (Högre = Mer Ackordbyte)</p>
                </div>

                <!-- 5. Inre Känslighet (Melodi - Not) - Korrigerad logik -->
                <div>
                    <label for="innerSensitivity" class="block text-sm font-medium mb-1">5. Melodi (Not/Oktav/Rytm) Känslighet</label>
                    <input type="range" id="innerSensitivity" value="3.0" min="1.0" max="5.0" step="0.1" oninput="updateSensitivityValue(this, 'innerSensitivityDescription')" onchange="redrawGrid()">
                    <!-- Notera att textinnehållet måste ligga i en span för att undvika krasch -->
                    <p class="text-xs text-gray-400 mt-1">Variation: <span id="innerSensitivityDescription" class="font-semibold">3.0</span> (Högre = Mindre dämpning)</p>
                </div>

                <!-- 6. Placeholder för framtida reglage -->
                <div class="hidden lg:block"></div>

                <!-- 7. Harmoni Klangfärg Känslighet -->
                <div>
                    <label for="harmonyFilterSensitivity" class="block text-sm font-medium mb-1">7. Harmoni Klangfärg Känslighet</label>
                    <input type="range" id="harmonyFilterSensitivity" value="3.0" min="1.0" max="5.0" step="0.1" oninput="updateSensitivityValue(this, 'harmonyFilterSensitivityDescription')">
                    <p class="text-xs text-gray-400 mt-1">Filtervariation: <span id="harmonyFilterSensitivityDescription" class="font-semibold">3.0</span> (Högre = Mer färgförändring)</p>
                </div>

                <!-- 8. Melodi Klangfärg Känslighet -->
                <div>
                    <label for="melodyFilterSensitivity" class="block text-sm font-medium mb-1">8. Melodi Klangfärg Känslighet</label>
                    <input type="range" id="melodyFilterSensitivity" value="3.0" min="1.0" max="5.0" step="0.1" oninput="updateSensitivityValue(this, 'melodyFilterSensitivityDescription')">
                    <p class="text-xs text-gray-400 mt-1">Filtervariation: <span id="melodyFilterSensitivityDescription" class="font-semibold">3.0</span> (Högre = Mer ljusstyrkeförändring)</p>
                </div>

                <!-- 9. Volymbalans -->
                <div>
                    <label for="volumeBalance" class="block text-sm font-medium mb-1">9. Volymbalans (Harmoni ↔ Melodi)</label>
                    <input type="range" id="volumeBalance" value="50" min="0" max="100" step="1" oninput="updateBalanceValue(this)">
                    <p class="text-xs text-gray-400 mt-1">Balans: <span id="balanceValue" class="font-semibold">50</span>% Harmoni</p>
                </div>
            </div>
        </div>

    </div>
	
        <!-- Canvas -->
        <canvas id="imageCanvas" class="w-full aspect-square" width="512" height="512"></canvas>

    <script>
        // Globala variabler för DOM-element och Tone.js instanser
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        const statusMessage = document.getElementById('statusMessage');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        
        let isImageLoaded = false;
        let sequence = null;

        // Tone.js Synth-instanser
        const harmonyFilter = new Tone.Filter(200, "lowpass", -12).toDestination();
        harmonyFilter.Q.value = 8; // Högre Q för tydligare effekt
        const melodyFilter = new Tone.Filter(1000, "lowpass", -12).toDestination();
        melodyFilter.Q.value = 8; // Högre Q för tydligare effekt

        const harmonySynth = new Tone.PolySynth(Tone.AMSynth, {
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.05, decay: 1.0, sustain: 0.2, release: 2.0 },
            volume: -10 // Startvolym, justeras av balanskontroll
        }).connect(harmonyFilter);

        const melodySynth = new Tone.MonoSynth({
            oscillator: { type: "square" },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 },
            filterEnvelope: { attack: 0.06, decay: 0.2, sustain: 0.5, release: 0.4, baseFrequency: 200, octaves: 4 },
            volume: -5 // Startvolym, justeras av balanskontroll
        }).connect(melodyFilter);

        // Musikalisk basdata
        const rootNotes = ["C", "D", "E", "F#", "G", "A", "B"];
        const scales = {
            'major': [0, 2, 4, 5, 7, 9, 11], // Dur
            'minor': [0, 2, 3, 5, 7, 8, 10], // Moll
            'major7': [0, 4, 7, 11], // Dur 7 (för harmoni)
            'minor7': [0, 3, 7, 10] // Moll 7 (för harmoni)
        };

        // --- Initiering och Hjälpfunktioner ---

        // Försök att starta Tone.js AudioContext efter användarinteraktion
        function initializeAudio() {
            if (Tone.Transport.state !== 'started') {
                Tone.start().then(() => {
                    statusMessage.textContent = "Ljudmotor redo. Ladda upp en bild!";
                    startButton.disabled = !isImageLoaded;
                }).catch(e => {
                    statusMessage.textContent = "Kunde inte starta ljudmotor: " + e.message;
                });
            }
        }

        // Uppdatera värde på känslighetsreglage
        function updateSensitivityValue(input, descId) {
            document.getElementById(descId).textContent = input.value;
        }

        // Uppdatera volymbalans och applicera på synthar
        function updateBalanceValue(input) {
            const balanceValue = parseInt(input.value);
            const harmGain = balanceValue / 100; // 0 till 1
            const meloGain = 1 - harmGain; // 1 till 0

            // Logaritmisk mappning för en jämnare volymkänsla
            const dbFromGain = (gain) => gain > 0 ? 20 * Math.log10(gain) : -100;

            const harmDb = dbFromGain(harmGain);
            const meloDb = dbFromGain(meloGain);

            harmonySynth.volume.value = harmDb;
            melodySynth.volume.value = meloDb;

            document.getElementById('balanceValue').textContent = `${balanceValue}`;
        }

        // Initialisera alla reglagens beskrivningsvärden vid laddning
        document.addEventListener('DOMContentLoaded', () => {
            initializeAudio();
            document.querySelectorAll('input[type="range"]').forEach(input => {
                if (input.id === 'volumeBalance') {
                    updateBalanceValue(input);
                } else if (input.id === 'sequenceDuration') {
                    document.getElementById('durationValue').textContent = input.value;
                } else {
                    const descId = input.id.replace('Sensitivity', 'SensitivityDescription');
                    document.getElementById(descId).textContent = input.value;
                }
            });

            // Lyssna på klick på hela kroppen för att säkerställa ljudinitiering
            document.body.addEventListener('click', initializeAudio, { once: true });
        });

        // --- Bildhantering och Färgextraktion ---

        function handleImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                img.onload = () => {
                    isImageLoaded = true;
                    statusMessage.textContent = "Bild laddad. Justera inställningar och starta sekvensen.";
                    startButton.disabled = false;
                    redrawGrid(); // Rita rutnätet vid ny bild
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function getAverageColor(x, y, width, height) {
            // Optimering: Sätt 'willReadFrequently' för snabbare läsning
            ctx.canvas.setAttribute('willReadFrequently', 'true');
            try {
                const imageData = ctx.getImageData(x, y, width, height);
                const data = imageData.data;
                let r = 0, g = 0, b = 0, count = 0;

                for (let i = 0; i < data.length; i += 4) {
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                    count++;
                }

                if (count === 0) return { r: 0, g: 0, b: 0, l: 0 };
                
                const avgR = r / count;
                const avgG = g / count;
                const avgB = b / count;

                // Beräkna Luminositet (Ljusstyrka)
                const luminosity = (0.2126 * avgR + 0.7152 * avgG + 0.0722 * avgB); // ITU-R BT.709

                return { r: avgR, g: avgG, b: avgB, l: luminosity };
            } catch (error) {
                console.error("Kunde inte läsa bilddata:", error);
                return { r: 0, g: 0, b: 0, l: 0 };
            }
        }

        // --- Mappningslogik: Färg till Musik ---

        function mapColorToHarmony(color, sensitivity) {
            // ** Harmoni Not & Skala **
            const colorValue = color.r; // Använd Röd för rotnot
            const scaleValue = color.g; // Använd Grön för skaltyp

            // Yttre känslighetsreglage (4. Harmoni Not/Ackord Känslighet)
            // Högre värde ger högre variation (lägre dämpning).
            const powerFactor = 6.0 - sensitivity; // 1.0 (hög sens) till 5.0 (låg sens)

            // Dämpa färgvärdet baserat på känslighet
            const dampenedR = Math.min(255, colorValue * powerFactor / 5.0); 
            const dampenedG = Math.min(255, scaleValue * powerFactor / 5.0); 

            // 1. Root Note (Mappa Röd till 7 toner)
            const rootIndex = Math.floor(dampenedR / (256 / rootNotes.length));
            const root = rootNotes[rootIndex % rootNotes.length] + '3'; // Alltid oktav 3

            // 2. Chord Type (Mappa Grön till 4 ackordtyper)
            let chordType;
            if (dampenedG < 64) {
                chordType = 'major7';
            } else if (dampenedG < 128) {
                chordType = 'minor7';
            } else if (dampenedG < 192) {
                chordType = 'major';
            } else {
                chordType = 'minor';
            }

            // ** Harmoni Filter **
            // Använd Blå kanal för att styra klangfärg (Reglage 7)
            const filterSensitivity = parseFloat(document.getElementById('harmonyFilterSensitivity').value);
            const b = color.b;
            const filterFactor = 6.0 - filterSensitivity; // 1.0 (hög sens) till 5.0 (låg sens)
            const dampenedB = Math.min(255, b * filterFactor / 5.0); 

            // Mappa 0-255 till 200 Hz - 4000 Hz
            const minFreq = 200;
            const maxFreq = 4000;
            const freq = minFreq + (maxFreq - minFreq) * (dampenedB / 255);

            return { root, chordType, filterFreq: freq };
        }

        function mapColorToMelodyNote(color, sensitivity, harmonyRoot, harmonyScaleType) {
            const l = color.l; // Luminositet för tonhöjd
            const g = color.g; // Grön för oktav
            const b = color.b; // Blå för rytm/decay

            // Inre känslighetsreglage (5. Melodi Not Känslighet)
            // Använd den omvända logiken som användaren föredrog (mindre dämpning när reglaget är högt)
            const powerFactor = sensitivity; // 1.0 (låg sens) till 5.0 (hög sens)

            // Dämpa färgvärden baserat på känslighet
            const dampenedL = Math.min(255, l * powerFactor / 5.0);
            const dampenedG = Math.min(255, g * powerFactor / 5.0);
            const dampenedB = Math.min(255, b * powerFactor / 5.0);

            // Hämta tillgängliga noter (Endast grundläggande dur/moll för Melodi-mappning)
            const scaleIntervals = scales[harmonyScaleType.includes('major') ? 'major' : 'minor'];

            // 1. Pitch (Tonhöjd): Mappa Luminositet till 7 skalsteg
            const scaleIndex = Math.floor(dampenedL / (256 / scaleIntervals.length));
            const interval = scaleIntervals[scaleIndex % scaleIntervals.length];

            // Konvertera rotnot (t.ex. "C3") till MIDI-nummer
            const rootMidi = Tone.Midi(harmonyRoot).toMidi();
            
            // Beräkna tonens MIDI-värde
            let melodyMidi = rootMidi + interval;
            
            // 2. Oktav: Mappa Grön kanal till oktavhöjd (t.ex. 4 till 6)
            const octaveShift = Math.floor(dampenedG / (256 / 3)) + 4; // 4, 5 eller 6
            
            melodyMidi += (octaveShift * 12) - rootMidi; // Flytta till den valda oktaven
            
            const note = Tone.Midi(melodyMidi).toNote();

            // 3. Rytm/Decay: Mappa Blå kanal till notlängd (release)
            const minRelease = 0.05;
            const maxRelease = 0.3;
            const release = minRelease + (maxRelease - minRelease) * (dampenedB / 255);

            // ** Melodi Filter **
            // Använd Luminositet (L) för att styra klangfärg (Reglage 8)
            const filterSensitivity = parseFloat(document.getElementById('melodyFilterSensitivity').value);
            const filterFactor = 6.0 - filterSensitivity; // 1.0 (hög sens) till 5.0 (låg sens)
            const dampenedLFilter = Math.min(255, l * filterFactor / 5.0);

            // Mappa 0-255 till 100 Hz - 10000 Hz
            const minFreq = 100;
            const maxFreq = 10000;
            const freq = minFreq + (maxFreq - minFreq) * (dampenedLFilter / 255);

            return { note, release, filterFreq: freq };
        }

        // --- UI Ritning ---

        function redrawGrid(currentOuterX = -1, currentOuterY = -1, currentInnerX = -1, currentInnerY = -1) {
            if (!isImageLoaded) return;

            const outerSize = parseInt(document.getElementById('outerGridSize').value);
            const innerSize = parseInt(document.getElementById('innerGridSize').value);
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const outerRectW = canvasWidth / outerSize;
            const outerRectH = canvasHeight / outerSize;

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

            // Ritar rutnät och markering
            for (let outerY = 0; outerY < outerSize; outerY++) {
                const outerRectY = outerY * outerRectH;
                for (let outerX = 0; outerX < outerSize; outerX++) {
                    const outerRectX = outerX * outerRectW;

                    const isCurrentOuter = (outerX === currentOuterX && outerY === currentOuterY);

                    // Rita Yttre Rutnät
                    ctx.strokeStyle = isCurrentOuter ? '#eab308' : 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = isCurrentOuter ? 3 : 1;
                    ctx.strokeRect(outerRectX, outerRectY, outerRectW, outerRectH);

                    // Om den stora rutan är aktiv, rita inre rutnät
                    if (isCurrentOuter) {
                        const innerRectW = outerRectW / innerSize;
                        const innerRectH = outerRectH / innerSize;

                        for (let innerY = 0; innerY < innerSize; innerY++) {
                            for (let innerX = 0; innerX < innerSize; innerX++) {
                                const innerRectX = outerRectX + innerX * innerRectW;
                                const innerRectY = outerRectY + innerY * innerRectH;
                                
                                const isCurrentInner = (innerX === currentInnerX && innerY === currentInnerY);

                                // Rita Inre Rutnät
                                ctx.strokeStyle = isCurrentInner ? '#22c55e' : 'rgba(255, 255, 255, 0.8)';
                                ctx.lineWidth = isCurrentInner ? 2 : 0.5;
                                ctx.strokeRect(innerRectX, innerRectY, innerRectW, innerRectH);
                                
                                // Fyll i den aktiva lilla rutan
                                if (isCurrentInner) {
                                    ctx.fillStyle = 'rgba(34, 197, 94, 0.4)'; // Grönt sken
                                    ctx.fillRect(innerRectX, innerRectY, innerRectW, innerRectH);
                                }
                            }
                        }
                    } else {
                         // Om den stora rutan är aktiv, fyll den subtilt
                        ctx.fillStyle = isCurrentOuter ? 'rgba(234, 179, 8, 0.2)' : 'transparent';
                        if (isCurrentOuter) ctx.fillRect(outerRectX, outerRectY, outerRectW, outerRectH);
                    }
                }
            }
        }

        // --- Sekvenseringslogik ---

        function startSequence() {
            if (!isImageLoaded) {
                statusMessage.textContent = "Ladda upp en bild först.";
                return;
            }
            
            // Stoppa eventuell existerande sekvens
            if (sequence) {
                sequence.stop();
                sequence.dispose();
            }

            // Starta AudioContext om det behöktes göras explicit igen
            Tone.start();

            startButton.disabled = true;
            stopButton.disabled = false;
            statusMessage.textContent = "Sekvensen spelar...";

            const outerSize = parseInt(document.getElementById('outerGridSize').value);
            const innerSize = parseInt(document.getElementById('innerGridSize').value);
            const totalSteps = outerSize * outerSize * innerSize * innerSize;
            const totalDurationMin = parseFloat(document.getElementById('sequenceDuration').value);
            const totalDurationSec = totalDurationMin * 60;

            // Beräkna BPM baserat på total tid och antal steg
            // Tone.Transport.bpm styrs av antalet 1/4-delar (kvartsnoter) per minut.
            // Vi vill att varje litet steg ska vara 1/16-del (sextondel), alltså 4 steg per kvartsnot.
            const bpm = (totalSteps / totalDurationSec) * 60 / 4; 
            Tone.Transport.bpm.value = bpm;

            // Skapa en array med alla sekvenssteg (Alla lilla rutor)
            const gridSequence = [];
            for (let outerY = 0; outerY < outerSize; outerY++) {
                for (let outerX = 0; outerX < outerSize; outerX++) {
                    for (let innerY = 0; innerY < innerSize; innerY++) {
                        for (let innerX = 0; innerX < innerSize; innerX++) {
                            // Varje objekt representerar en liten ruta
                            gridSequence.push({ outerX, outerY, innerX, innerY });
                        }
                    }
                }
            }

            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const outerRectW = canvasWidth / outerSize;
            const outerRectH = canvasHeight / outerSize;
            const innerRectW = outerRectW / innerSize;
            const innerRectH = outerRectH / innerSize;

            let lastHarmony = null;
            const outerSensitivity = parseFloat(document.getElementById('outerSensitivity').value);
            const innerSensitivity = parseFloat(document.getElementById('innerSensitivity').value);

            sequence = new Tone.Sequence((time, step) => {
                const { outerX, outerY, innerX, innerY } = step;

                // Beräkna den stora rutans position och färg
                const outerRectX = outerX * outerRectW;
                const outerRectY = outerY * outerRectH;
                const outerColor = getAverageColor(outerRectX, outerRectY, outerRectW, outerRectH);
                
                // Beräkna den lilla rutans position och färg
                const innerRectX = outerRectX + innerX * innerRectW;
                const innerRectY = outerRectY + innerY * innerRectH;
                const innerColor = getAverageColor(innerRectX, innerRectY, innerRectW, innerRectH);
                
                // Uppdatera UI-markeringen
                Tone.Draw.schedule(() => {
                    redrawGrid(outerX, outerY, innerX, innerY);
                }, time);

                // --- 1. HARMONI (Endast vid första steget i den stora rutan) ---
                if (innerX === 0 && innerY === 0) {
                    const { root, chordType, filterFreq } = mapColorToHarmony(outerColor, outerSensitivity);
                    const chord = [root, rootNotes[(rootNotes.indexOf(root.replace(/\d/g, '')) + scales[chordType][1]) % rootNotes.length] + '4', rootNotes[(rootNotes.indexOf(root.replace(/\d/g, '')) + scales[chordType][2]) % rootNotes.length] + '4'];
                    
                    // Om det är en 7:a, lägg till den 4:e noten
                    if (chordType.includes('7')) {
                        chord.push(rootNotes[(rootNotes.indexOf(root.replace(/\d/g, '')) + scales[chordType][3]) % rootNotes.length] + '5');
                    }
                    
                    // Spela ackordet
                    harmonySynth.triggerAttackRelease(chord, "2n", time);
                    harmonyFilter.frequency.setValueAtTime(filterFreq, time);
                    
                    lastHarmony = { root, scaleType: chordType };
                }

                // --- 2. MELODI (Varje litet steg) ---
                if (lastHarmony) {
                    const { note, release, filterFreq } = mapColorToMelodyNote(innerColor, innerSensitivity, lastHarmony.root, lastHarmony.scaleType);
                    
                    // Spela noten
                    melodySynth.triggerAttackRelease(note, release, time);
                    melodyFilter.frequency.setValueAtTime(filterFreq, time);
                }
                
                // --- 3. SLUT (Stoppa sekvensen när sista steget nås) ---
                if (outerX === outerSize - 1 && outerY === outerSize - 1 && innerX === innerSize - 1 && innerY === innerSize - 1) {
                    Tone.Draw.schedule(() => {
                        stopSequence();
                    }, time + Tone.Transport.toSeconds('4n')); // Stoppa efter en kort fördröjning
                }
            }, gridSequence, "16n"); // Sekvensera på 16-delsnoter

            Tone.Transport.start();
            sequence.start(0);
        }

        function stopSequence() {
            if (sequence) {
                sequence.stop();
                sequence.dispose();
                sequence = null;
            }
            Tone.Transport.stop();
            
            // Släpp syntharna för att undvika ihållande ljud
            harmonySynth.releaseAll();
            // MonoSynth har inte releaseAll, så vi släpper en tom attack för att släcka ljudet
            melodySynth.triggerRelease();

            // Återställ UI
            startButton.disabled = !isImageLoaded;
            stopButton.disabled = true;
            statusMessage.textContent = "Sekvens stoppad. Klicka Starta igen eller ladda ny bild.";
            redrawGrid(); // Rensa markeringar
        }

        // Koppla händelselyssnare till DOM-elementen vid laddning
        document.addEventListener('DOMContentLoaded', () => {
            document.body.addEventListener('click', initializeAudio, { once: true });
            document.getElementById('imageCanvas').addEventListener('click', initializeAudio, { once: true });
            // Initialisera volymbalansreglaget
            updateBalanceValue(document.getElementById('volumeBalance'));
        });

    </script>
</body>
</html>