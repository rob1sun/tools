<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Filkrypto &amp; Signering – Classic Minimal (v1.0.1-classic)</title>
  <style>
    :root { --bg:#0b1020; --fg:#e9ecf1; --muted:#aab3c0; --card:#121a33; --ok:#35d07f; --warn:#ffcc66; --err:#ff6b6b; }
    *{box-sizing:border-box}
    body{margin:0;background:#0b1020;color:var(--fg);font-family:-apple-system,system-ui,Segoe UI,Roboto,Helvetica,Arial,Noto Sans,sans-serif}
    header{padding:20px 16px;text-align:center}
    h1{margin:0 0 6px 0;font-size:1.4rem}
    header p{margin:0;color:var(--muted)}
    main{max-width:1100px;margin:0 auto;padding:16px}
    .card{background:rgba(18,26,51,.95);border:1px solid rgba(255,255,255,.08);border-radius:14px;box-shadow:0 8px 22px rgba(0,0,0,.25);padding:16px;margin:0 0 14px 0}
    .card h2{margin:0 0 10px 0;font-size:1.06rem}
    .card p{color:var(--muted);margin:6px 0 12px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-size:.9rem;color:var(--muted);display:block;margin:.2rem 0 .4rem}
    input[type="file"],textarea,input[type="password"],input[type="text"],select{width:100%;background:#0e1530;color:var(--fg);border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:10px 12px;font-size:.94rem}
    textarea{min-height:110px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .btn{appearance:none;border:1px solid rgba(255,255,255,.15);padding:10px 14px;border-radius:10px;background:#172044;color:var(--fg);font-weight:600;cursor:pointer}
    .btn:hover{background:#1b2653}
    .btn.ok{background:#14492f;border-color:rgba(53,208,127,.4)}
    .btn.err{background:#5a1e1e;border-color:rgba(255,107,107,.45)}
    .btn.warn{background:#4d3a09;border-color:rgba(255,204,102,.45)}
    .status{padding:10px 12px;border-radius:10px;background:#0d1430;border:1px dashed rgba(255,255,255,.15);color:var(--muted);white-space:pre-wrap;word-break:break-word;margin-top:10px}
    footer{max-width:1100px;margin:18px auto 36px;padding:0 16px;color:var(--muted);font-size:.9rem}
  </style>
</head>
<body>
  <header>
    <h1>Filkryptering &amp; Signering – Classic</h1>
    <p>Web Crypto (AES-GCM + RSA-OAEP) och ECDSA P-256. Privata nycklar lagras krypterat i IndexedDB och kr&auml;ver l&ouml;senord (valfritt WebAuthn) f&ouml;r att anv&auml;ndas.</p>
  </header>

  <main>
    <section class="card" id="env">
      <h2>0) Milj&ouml;koll</h2>
      <div class="status" id="envStatus">Init...</div>
    </section>

    <section class="card" id="vault">
      <h2>1) S&auml;kerhetsl&aring;s</h2>
      <div class="row">
        <div style="flex:1;min-width:280px">
          <label>Skapa/&auml;ndra l&ouml;senord</label>
          <input type="password" id="setPass1" placeholder="Nytt l&ouml;senord" autocomplete="new-password" />
          <input type="password" id="setPass2" placeholder="Bekr&auml;fta l&ouml;senord" autocomplete="new-password" style="margin-top:8px" />
          <div class="row" style="margin-top:8px">
            <button class="btn" id="setPassBtn">Spara l&ouml;senord</button>
            <button class="btn warn" id="exportVaultBtn">Exportera backup (.keyvault.json)</button>
            <input type="file" id="importVaultFile" accept="application/json" />
          </div>
        </div>
        <div style="flex:1;min-width:280px">
          <label>L&aring;s upp f&ouml;r sessionen</label>
          <input type="password" id="unlockPass" placeholder="L&ouml;senord f&ouml;r uppl&aring;sning" autocomplete="current-password" />
          <div class="row" style="margin-top:8px">
            <select id="autoLockMins" style="max-width:180px">
              <option value="5" selected>Auto-l&aring;s: 5 min</option>
              <option value="1">Auto-l&aring;s: 1 min</option>
              <option value="15">Auto-l&aring;s: 15 min</option>
              <option value="0">Ingen auto-l&aring;sning</option>
            </select>
            <button class="btn ok" id="unlockBtn">L&aring;s upp</button>
            <button class="btn" id="lockNowBtn">L&aring;s nu</button>
            <button class="btn err" id="wipeBtn">Rensa allt</button>
          </div>
          <div class="row" style="margin-top:8px">
            <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="requireWebAuthn" /> Kr&auml;v WebAuthn (2FA) vid uppl&aring;sning</label>
            <button class="btn" id="regWebAuthnBtn">Registrera WebAuthn</button>
            <button class="btn" id="testWebAuthnBtn">Testa</button>
            <button class="btn" id="removeWebAuthnBtn">Ta bort</button>
          </div>
          <div class="status" id="vaultStatus">-</div>
          <div class="row small" style="margin-top:6px"><div id="webauthnState">WebAuthn: unknown</div><div id="lockState"> | Lock: unknown</div></div>
        </div>
      </div>
    </section>

    <section class="card" id="keys">
      <h2>2) Nycklar</h2>
      <p>Skapar krypteringsnyckel (RSA-OAEP 4096) och signeringsnyckel (ECDSA P-256). Publika nycklar kan exporteras nedan.</p>
      <button class="btn" id="genKeys">Generera b&aring;da nyckelparen</button>
      <div class="row" style="margin-top:12px">
        <div style="flex:1;min-width:280px">
          <label>Publik krypteringsnyckel (JWK)</label>
          <textarea id="pubEncOut" readonly placeholder="Exportera..."></textarea>
          <div class="row" style="margin-top:8px">
            <button class="btn" id="exportPubEnc">Exportera</button>
            <button class="btn" id="downloadPubEnc">Ladda ned .pubkey.json</button>
          </div>
        </div>
        <div style="flex:1;min-width:280px">
          <label>Publik signeringsnyckel (JWK)</label>
          <textarea id="pubSignOut" readonly placeholder="Exportera..."></textarea>
          <div class="row" style="margin-top:8px">
            <button class="btn" id="exportPubSign">Exportera</button>
            <button class="btn" id="downloadPubSign">Ladda ned .pubsigkey.json</button>
          </div>
        </div>
      </div>
      <div class="status" id="keysStatus">-</div>
    </section>

    <section class="card" id="import">
      <h2>3) Importera mottagarens publika krypteringsnyckel</h2>
      <textarea id="theirPubJwk" placeholder='{"kty":"RSA","n":"...","e":"AQAB"}'></textarea>
      <div class="row" style="margin-top:8px">
        <input type="file" id="theirPubFile" accept="application/json" />
        <button class="btn" id="importTheirPub">Importera</button>
      </div>
      <div class="status" id="importStatus">-</div>
    </section>

    <section class="card" id="encrypt">
      <h2>4) Kryptera fil</h2>
      <input type="file" id="encFile" />
      <div class="row" style="margin-top:8px"><button class="btn ok" id="doEncrypt">Kryptera &amp; ladda ned .enc.json</button></div>
      <div class="status" id="encStatus">-</div>
    </section>

    <section class="card" id="decrypt">
      <h2>5) Dekryptera fil (.enc.json)</h2>
      <input type="file" id="decFile" accept="application/json" />
      <div class="row" style="margin-top:8px"><button class="btn ok" id="doDecrypt">Dekryptera &amp; ladda ned original</button></div>
      <div class="status" id="decStatus">-</div>
    </section>

    <section class="card" id="sign">
      <h2>6) Signera dokument</h2>
      <input type="file" id="signFile" />
      <div class="row" style="margin-top:8px"><button class="btn ok" id="doSign">Signera &amp; ladda ned .sig.json</button></div>
      <div class="status" id="signStatus">-</div>
    </section>

    <section class="card" id="verify">
      <h2>7) Verifiera signatur</h2>
      <div class="row">
        <input type="file" id="verifyFile" />
        <input type="file" id="verifySig" accept="application/json" />
      </div>
      <div class="row" style="margin-top:8px"><button class="btn" id="doVerify">Verifiera</button></div>
      <div class="status" id="verifyStatus">-</div>
    </section>
  </main>

  <footer>
    <p>Tips: K&ouml;r &ouml;ver https (eller http://localhost) f&ouml;r WebAuthn. Version <span id="appVersion"></span></p>
  </footer>

<script>
(function(){
  "use strict";
  var APP_VERSION = "v1.0.1-classic (2025-09-03)";
  function setVersion(){ var el=document.getElementById("appVersion"); if(el) el.textContent=APP_VERSION; }
  if(document.readyState==="loading"){ document.addEventListener("DOMContentLoaded", setVersion); } else { setVersion(); }

  // Env check
  function env(){ var secure=(window.isSecureContext===true); var hasWC=!!(window.crypto&&crypto.subtle); var hasIDB=("indexedDB" in window); var hasWA=("PublicKeyCredential" in window); var el=document.getElementById("envStatus"); if(!el) return; el.textContent = ["SecureContext: "+secure, "WebCrypto: "+hasWC, "IndexedDB: "+hasIDB, "WebAuthn: "+hasWA].join("
"); }
  if(document.readyState==="loading"){ document.addEventListener("DOMContentLoaded", env); } else { env(); }

  // IndexedDB
  var dbp = new Promise(function(resolve,reject){ try{ var open=indexedDB.open("crypto-classic-v101",1); open.onupgradeneeded=function(){ open.result.createObjectStore("kv"); }; open.onsuccess=function(){ resolve(open.result); }; open.onerror=function(){ reject(open.error); }; }catch(e){ reject(e); } });
  function dbGet(key){ return dbp.then(function(db){ return new Promise(function(res,rej){ try{ var tx=db.transaction("kv"); var st=tx.objectStore("kv"); var req=st.get(key); req.onsuccess=function(){ res(req.result); }; req.onerror=function(){ rej(req.error); }; }catch(e){ rej(e); } }); }); }
  function dbSet(key,val){ return dbp.then(function(db){ return new Promise(function(res,rej){ try{ var tx=db.transaction("kv","readwrite"); var st=tx.objectStore("kv"); var req=st.put(val,key); req.onsuccess=function(){ res(true); }; req.onerror=function(){ rej(req.error); }; }catch(e){ rej(e); } }); }); }
  function dbDel(key){ return dbp.then(function(db){ return new Promise(function(res,rej){ try{ var tx=db.transaction("kv","readwrite"); var st=tx.objectStore("kv"); var req=st.delete(key); req.onsuccess=function(){ res(true); }; req.onerror=function(){ rej(req.error); }; }catch(e){ rej(e); } }); }); }

  // Utils (ASCII-only strings)
  var te=new TextEncoder(); var td=new TextDecoder();
  function toB64(buf){ return btoa(String.fromCharCode.apply(null,new Uint8Array(buf))); }
  function fromB64(b64){ return Uint8Array.from(atob(b64),function(c){ return c.charCodeAt(0); }).buffer; }
  function toHex(buf){ var a=new Uint8Array(buf); var s=""; for(var i=0;i<a.length;i++){ var h=a[i].toString(16); if(h.length<2) h="0"+h; s+=h; } return s; }
  function download(name,data,type){ var blob=(data instanceof Blob)? data : new Blob([data],{type:type||"application/octet-stream"}); var url=URL.createObjectURL(blob); var a=document.createElement("a"); a.href=url; a.download=name; a.click(); setTimeout(function(){ URL.revokeObjectURL(url); },1500); }
  function downloadJSON(name,obj){ download(name,new Blob([JSON.stringify(obj,null,2)],{type:"application/json"}),"application/json"); }
  function status(sel,msg,tone){ var el=document.querySelector(sel); if(!el) return; el.textContent=msg; if(tone==="ok"){ el.style.borderColor="rgba(53,208,127,.45)"; el.style.color="var(--ok)"; } else if(tone==="warn"){ el.style.borderColor="rgba(255,204,102,.45)"; el.style.color="var(--warn)"; } else if(tone==="err"){ el.style.borderColor="rgba(255,107,107,.45)"; el.style.color="var(--err)"; } else { el.style.borderColor="rgba(255,255,255,.15)"; el.style.color="var(--muted)"; } }

  // Vault (PBKDF2 + AES-GCM)
  function deriveAesKey(password,salt,iterations){ return crypto.subtle.importKey("raw", te.encode(password), {name:"PBKDF2"}, false, ["deriveKey"]).then(function(baseKey){ return crypto.subtle.deriveKey({name:"PBKDF2", salt:salt, iterations:iterations, hash:"SHA-256"}, baseKey, {name:"AES-GCM", length:256}, false, ["encrypt","decrypt"]); }); }
  function encryptJSON(obj,password,iterations){ iterations=iterations||200000; var salt=crypto.getRandomValues(new Uint8Array(16)); var iv=crypto.getRandomValues(new Uint8Array(12)); return deriveAesKey(password,salt,iterations).then(function(aesKey){ var pt=te.encode(JSON.stringify(obj)); return crypto.subtle.encrypt({name:"AES-GCM", iv:iv}, aesKey, pt).then(function(ct){ return {v:1,kdf:{name:"PBKDF2",hash:"SHA-256",iterations:iterations,salt:toB64(salt)},enc:{algo:"AES-GCM",iv:toB64(iv),ciphertext:toB64(ct)}}; }); }); }
  function decryptJSON(vaultObj,password){ var kdf=vaultObj.kdf; var enc=vaultObj.enc; var salt=new Uint8Array(fromB64(kdf.salt)); var iv=new Uint8Array(fromB64(enc.iv)); return deriveAesKey(password,salt,kdf.iterations).then(function(aesKey){ return crypto.subtle.decrypt({name:"AES-GCM", iv:iv}, aesKey, fromB64(enc.ciphertext)); }).then(function(pt){ return JSON.parse(td.decode(pt)); }); }

  // State
  var unlocked=false, autoLockTimer=null, autoLockMinutes=5;
  var priv={ encKey:null, signKey:null }; var pubJwk={ enc:null, sign:null }; var theirEncPubKey=null;
  var webauthnCred=null, webauthnRequired=false;
  function touch(){ if(autoLockTimer) clearTimeout(autoLockTimer); if(autoLockMinutes && autoLockMinutes>0){ autoLockTimer=setTimeout(lockNow, autoLockMinutes*60*1000); } }
  function setLockState(){ var s=document.getElementById("lockState"); if(!s) return; s.textContent = "Lock: "+(unlocked?"unlocked":"locked"); }
  function lockNow(){ priv.encKey=null; priv.signKey=null; unlocked=false; setLockState(); status("#vaultStatus","Locked","ok"); }

  // Keys
  function generateKeys(){ var p1=document.getElementById("setPass1").value || document.getElementById("unlockPass").value; var p2=document.getElementById("setPass2").value || document.getElementById("unlockPass").value; if(!p1 || p1!==p2){ status("#keysStatus","Set same password in both fields","warn"); return; } status("#keysStatus","Generating RSA-OAEP 4096..."); crypto.subtle.generateKey({name:"RSA-OAEP", modulusLength:4096, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256"}, true, ["encrypt","decrypt","unwrapKey"]).then(function(encPair){ status("#keysStatus","Generating ECDSA P-256..."); crypto.subtle.generateKey({name:"ECDSA", namedCurve:"P-256"}, true, ["sign","verify"]).then(function(signPair){ Promise.all([ crypto.subtle.exportKey("jwk", encPair.privateKey), crypto.subtle.exportKey("jwk", encPair.publicKey), crypto.subtle.exportKey("jwk", signPair.privateKey), crypto.subtle.exportKey("jwk", signPair.publicKey) ]).then(function(arr){ var encPrivJwk=arr[0], encPub=arr[1], signPrivJwk=arr[2], signPub=arr[3]; pubJwk.enc=encPub; pubJwk.sign=signPub; dbSet("pub.enc.jwk", encPub); dbSet("pub.sign.jwk", signPub); encryptJSON({encPrivJwk:encPrivJwk, signPrivJwk:signPrivJwk}, p1).then(function(vault){ dbSet("vault", vault).then(function(){ priv.encKey=null; priv.signKey=null; unlocked=false; setLockState(); status("#keysStatus","Keys generated and stored (encrypted)","ok"); status("#vaultStatus","Vault updated","ok"); }); }); }); }); }).catch(function(e){ status("#keysStatus","Error: "+e.message,"err"); }); }
  function exportPubEnc(){ (pubJwk.enc? Promise.resolve(pubJwk.enc) : dbGet("pub.enc.jwk")).then(function(jwk){ if(!jwk){ status("#keysStatus","No public enc key","warn"); return; } document.getElementById("pubEncOut").value=JSON.stringify(jwk,null,2); }); }
  function exportPubSign(){ (pubJwk.sign? Promise.resolve(pubJwk.sign) : dbGet("pub.sign.jwk")).then(function(jwk){ if(!jwk){ status("#keysStatus","No public sign key","warn"); return; } document.getElementById("pubSignOut").value=JSON.stringify(jwk,null,2); }); }

  // Vault ops
  function setPassword(){ var p1=document.getElementById("setPass1").value.trim(); var p2=document.getElementById("setPass2").value.trim(); if(!p1||p1!==p2){ status("#vaultStatus","Passwords must match","warn"); return; } dbGet("vault").then(function(existing){ if(existing){ var oldPass=document.getElementById("unlockPass").value || p1; decryptJSON(existing,oldPass).then(function(payload){ encryptJSON(payload,p1).then(function(newV){ dbSet("vault",newV).then(function(){ status("#vaultStatus","Password updated","ok"); }); }); }).catch(function(){ status("#vaultStatus","Unlock with old password first","err"); }); } else { encryptJSON({},p1).then(function(newV){ dbSet("vault",newV).then(function(){ status("#vaultStatus","Password set. Generate keys next","ok"); }); }); } }); }
  function unlockNow(){ var pass=document.getElementById("unlockPass").value.trim(); if(!pass){ status("#vaultStatus","Fill password","warn"); return; } dbGet("vault").then(function(vault){ if(!vault){ status("#vaultStatus","No vault. Generate keys first","warn"); return; } decryptJSON(vault,pass).then(function(payload){ if(!payload.encPrivJwk||!payload.signPrivJwk){ status("#vaultStatus","Vault has no keys","warn"); return; } function importKeys(){ Promise.all([ crypto.subtle.importKey("jwk", payload.encPrivJwk, {name:"RSA-OAEP", hash:"SHA-256"}, false, ["decrypt","unwrapKey"]), crypto.subtle.importKey("jwk", payload.signPrivJwk, {name:"ECDSA", namedCurve:"P-256"}, false, ["sign"]) ]).then(function(k){ priv.encKey=k[0]; priv.signKey=k[1]; unlocked=true; touch(); setLockState(); status("#vaultStatus","Unlocked","ok"); }); }
      if(webauthnRequired){ webauthnAssert().then(function(ok){ if(ok) importKeys(); else status("#vaultStatus","WebAuthn failed/cancelled","err"); }); } else { importKeys(); }
    }).catch(function(e){ status("#vaultStatus","Unlock error: "+e.message,"err"); }); }); }
  function exportVault(){ dbGet("vault").then(function(v){ if(!v){ status("#vaultStatus","No vault to export","warn"); return; } downloadJSON("keys.keyvault.json", v); }); }
  function importVaultFromFile(ev){ var f=ev.target.files[0]; if(!f) return; f.text().then(function(txt){ try{ var v=JSON.parse(txt); if(!v.enc||!v.kdf) throw new Error("Invalid vault"); dbSet("vault",v).then(function(){ status("#vaultStatus","Vault imported","ok"); }); }catch(e){ status("#vaultStatus","Import error: "+e.message,"err"); } }); }
  function wipeAll(){ Promise.all([dbDel("vault"), dbDel("pub.enc.jwk"), dbDel("pub.sign.jwk"), dbDel("webauthn.cred"), dbDel("webauthn.required")]).then(function(){ priv.encKey=null; priv.signKey=null; pubJwk={enc:null,sign:null}; webauthnCred=null; webauthnRequired=false; unlocked=false; setLockState(); status("#vaultStatus","Cleared in this browser","ok"); updateWebAuthnState(); }); }

  // WebAuthn (local gate only)
  function b64urlToUint8(str){ var pad="=".repeat((4-(str.length%4))%4); var b64=(str+pad).replace(/-/g,"+").replace(/_/g,"/"); var bin=atob(b64); var arr=new Uint8Array(bin.length); for(var i=0;i<bin.length;i++){ arr[i]=bin.charCodeAt(i); } return arr; }
  function uint8ToB64url(buf){ var b=String.fromCharCode.apply(null, new Uint8Array(buf)); return btoa(b).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,''); }
  function getRpId(){ try{ return location.hostname||undefined; }catch(e){ return undefined; } }
  function registerWebAuthn(){ if(!("PublicKeyCredential" in window)){ status("#vaultStatus","WebAuthn not supported","err"); return; } try{ var userId=crypto.getRandomValues(new Uint8Array(16)); var challenge=crypto.getRandomValues(new Uint8Array(32)); var publicKey={ challenge:challenge, rp:{name:"Local Crypto App", id:getRpId()}, user:{ id:userId, name:"local-user", displayName:"Local User" }, pubKeyCredParams:[{type:"public-key",alg:-7},{type:"public-key",alg:-257}], timeout:60000, authenticatorSelection:{ userVerification:"required" }, attestation:"none" }; navigator.credentials.create({publicKey:publicKey}).then(function(cred){ var id=uint8ToB64url(cred.rawId); var store={ id:id }; dbSet("webauthn.cred",store).then(function(){ webauthnCred=store; updateWebAuthnState(); status("#vaultStatus","WebAuthn registered","ok"); }); }).catch(function(e){ status("#vaultStatus","Registration failed: "+e.message,"err"); }); }catch(e){ status("#vaultStatus","Registration failed: "+e.message,"err"); }
  }
  function webauthnAssert(){ return new Promise(function(resolve){ try{ var p=(webauthnCred? Promise.resolve(webauthnCred) : dbGet("webauthn.cred")); p.then(function(i){ if(!i){ resolve(false); return; } var allow=[{ type:"public-key", id:b64urlToUint8(i.id) }]; var challenge=crypto.getRandomValues(new Uint8Array(32)); navigator.credentials.get({ publicKey:{ challenge:challenge, allowCredentials:allow, userVerification:"required", timeout:60000, rpId:getRpId() } }).then(function(){ resolve(true); }).catch(function(){ resolve(false); }); }); }catch(e){ resolve(false); } }); }
  function updateWebAuthnState(){ Promise.all([dbGet("webauthn.cred"), dbGet("webauthn.required")]).then(function(arr){ var cred=arr[0]; var req=(arr[1]===true)||webauthnRequired; webauthnCred=cred||null; webauthnRequired=!!req; var lab=document.getElementById("webauthnState"); if(lab){ lab.textContent = "WebAuthn: "+(webauthnCred?"registered":"none")+" | require: "+(webauthnRequired?"on":"off"); } var cb=document.getElementById("requireWebAuthn"); if(cb) cb.checked=webauthnRequired; setLockState(); }); }

  // Import recipient public key
  function importRecipientFromText(){ try{ var raw=document.getElementById("theirPubJwk").value.trim(); if(!raw){ status("#importStatus","Paste JWK first","warn"); return; } var jwk=JSON.parse(raw); if(jwk.kty!=="RSA"){ throw new Error("Need RSA JWK for RSA-OAEP"); } crypto.subtle.importKey("jwk", jwk, {name:"RSA-OAEP", hash:"SHA-256"}, true, ["encrypt"]).then(function(k){ theirEncPubKey=k; status("#importStatus","Public key imported","ok"); }); }catch(e){ status("#importStatus","Import error: "+e.message,"err"); } }
  function theirPubFileChanged(ev){ var f=ev.target.files[0]; if(!f) return; f.text().then(function(txt){ document.getElementById("theirPubJwk").value=txt; importRecipientFromText(); }).catch(function(e){ status("#importStatus","File error: "+e.message,"err"); }); }

  // Encrypt / Decrypt
  function encryptForRecipient(){ var file=document.getElementById("encFile").files[0]; if(!file){ status("#encStatus","Select a file","warn"); return; } if(!theirEncPubKey){ status("#encStatus","Import recipient public key first","warn"); return; } file.arrayBuffer().then(function(data){ crypto.subtle.generateKey({name:"AES-GCM", length:256}, true, ["encrypt","decrypt"]).then(function(aesKey){ var iv=crypto.getRandomValues(new Uint8Array(12)); crypto.subtle.encrypt({name:"AES-GCM", iv:iv}, aesKey, data).then(function(ct){ crypto.subtle.wrapKey("raw", aesKey, theirEncPubKey, {name:"RSA-OAEP"}).then(function(wrapped){ var pkg={ type:"hybrid-enc", encAlgo:"AES-GCM", iv:toB64(iv), wrappedKeyAlgo:"RSA-OAEP", wrappedKey:toB64(wrapped), ciphertext:toB64(ct), filename:file.name, mime:file.type||"application/octet-stream", size:file.size, createdAt:new Date().toISOString() }; downloadJSON(file.name+".enc.json", pkg); status("#encStatus","Done","ok"); }); }); }); }).catch(function(e){ status("#encStatus","Error: "+e.message,"err"); }); }
  function ensureUnlocked(where){ if(unlocked && priv.encKey && priv.signKey) return true; status(where||"#vaultStatus","Unlock session first","warn"); return false; }
  function decryptForMe(){ if(!ensureUnlocked("#decStatus")) return; var file=document.getElementById("decFile").files[0]; if(!file){ status("#decStatus","Select .enc.json","warn"); return; } file.text().then(function(txt){ try{ var pkg=JSON.parse(txt); if(pkg.type!=="hybrid-enc") throw new Error("Unknown format"); var iv=new Uint8Array(fromB64(pkg.iv)); var wrapped=fromB64(pkg.wrappedKey); crypto.subtle.unwrapKey("raw", wrapped, priv.encKey, {name:"RSA-OAEP"}, {name:"AES-GCM", length:256}, true, ["decrypt"]).then(function(aesKey){ crypto.subtle.decrypt({name:"AES-GCM", iv:iv}, aesKey, fromB64(pkg.ciphertext)).then(function(pt){ var out=new Blob([pt],{type:pkg.mime||"application/octet-stream"}); var nm=(pkg.filename||"file")+".decrypted"; download(nm,out,out.type); status("#decStatus","Done","ok"); }); }); }catch(e){ status("#decStatus","Error: "+e.message,"err"); } }).catch(function(e){ status("#decStatus","Error: "+e.message,"err"); }); }

  // Sign & Verify
  function signFile(){ if(!ensureUnlocked("#signStatus")) return; var f=document.getElementById("signFile").files[0]; if(!f){ status("#signStatus","Select a file","warn"); return; } f.arrayBuffer().then(function(data){ crypto.subtle.digest("SHA-256", data).then(function(d){ crypto.subtle.sign({name:"ECDSA", hash:"SHA-256"}, priv.signKey, d).then(function(sig){ (pubJwk.sign? Promise.resolve(pubJwk.sign) : dbGet("pub.sign.jwk")).then(function(pub){ var pkg={ type:"ecdsa-detached-sig", algorithm:"ECDSA-P256-SHA256", file:{name:f.name,size:f.size,mime:f.type||"application/octet-stream"}, sha256:toHex(d), signature:toB64(sig), publicKeyJwk:pub, createdAt:new Date().toISOString() }; downloadJSON(f.name+".sig.json", pkg); status("#signStatus","Done","ok"); }); }); }); }).catch(function(e){ status("#signStatus","Error: "+e.message,"err"); }); }
  function verifySig(){ var f=document.getElementById("verifyFile").files[0]; var s=document.getElementById("verifySig").files[0]; if(!f||!s){ status("#verifyStatus","Select file and .sig.json","warn"); return; } Promise.all([f.arrayBuffer(), s.text()]).then(function(arr){ var data=arr[0]; var sigTxt=arr[1]; try{ var pkg=JSON.parse(sigTxt); if(pkg.type!=="ecdsa-detached-sig") throw new Error("Unknown sig format"); crypto.subtle.digest("SHA-256", data).then(function(d){ if(toHex(d)!==pkg.sha256){ status("#verifyStatus","Hash mismatch","err"); return; } crypto.subtle.importKey("jwk", pkg.publicKeyJwk, {name:"ECDSA", namedCurve:"P-256"}, true, ["verify"]).then(function(pubKey){ crypto.subtle.verify({name:"ECDSA", hash:"SHA-256"}, pubKey, fromB64(pkg.signature), d).then(function(ok){ status("#verifyStatus", ok?"Signature VALID":"Signature INVALID", ok?"ok":"err"); }); }); }); }catch(e){ status("#verifyStatus","Error: "+e.message,"err"); } }); }

  // Wire up
  function on(id,ev,fn){ var el=document.getElementById(id); if(el) el.addEventListener(ev,fn); }
  function wire(){ on("setPassBtn","click",setPassword); on("unlockBtn","click",function(){ var sel=document.getElementById("autoLockMins"); autoLockMinutes=sel?parseInt(sel.value,10):5; unlockNow(); }); on("lockNowBtn","click",lockNow); on("wipeBtn","click",wipeAll); on("exportVaultBtn","click",exportVault); on("importVaultFile","change",importVaultFromFile); on("regWebAuthnBtn","click",registerWebAuthn); on("testWebAuthnBtn","click",function(){ webauthnAssert().then(function(ok){ status("#vaultStatus", ok?"WebAuthn OK":"WebAuthn failed/cancelled", ok?"ok":"err"); }); }); on("removeWebAuthnBtn","click",function(){ dbDel("webauthn.cred").then(function(){ webauthnCred=null; status("#vaultStatus","WebAuthn removed","ok"); updateWebAuthnState(); }); }); on("requireWebAuthn","change",function(){ webauthnRequired=!!document.getElementById("requireWebAuthn").checked; dbSet("webauthn.required",webauthnRequired).then(updateWebAuthnState); }); on("genKeys","click",generateKeys); on("exportPubEnc","click",exportPubEnc); on("exportPubSign","click",exportPubSign); on("downloadPubEnc","click",function(){ var val=document.getElementById("pubEncOut").value.trim(); if(!val){ status("#keysStatus","Export first","warn"); return; } download("public-encryption-key.pubkey.json", new Blob([val],{type:"application/json"}), "application/json"); }); on("downloadPubSign","click",function(){ var val=document.getElementById("pubSignOut").value.trim(); if(!val){ status("#keysStatus","Export first","warn"); return; } download("public-signing-key.pubsigkey.json", new Blob([val],{type:"application/json"}), "application/json"); }); on("importTheirPub","click",importRecipientFromText); on("theirPubFile","change",theirPubFileChanged); on("doEncrypt","click",encryptForRecipient); on("doDecrypt","click",decryptForMe); on("doSign","click",signFile); on("doVerify","click",verifySig); document.addEventListener("click",touch); document.addEventListener("keydown",touch); }

  function init(){ Promise.all([ dbGet("pub.enc.jwk"), dbGet("pub.sign.jwk"), dbGet("webauthn.cred"), dbGet("webauthn.required"), dbGet("vault") ]).then(function(arr){ pubJwk.enc=arr[0]; pubJwk.sign=arr[1]; webauthnCred=arr[2]; webauthnRequired=(arr[3]===true); setLockState(); updateWebAuthnState(); var hasVault=!!arr[4]; status("#keysStatus","Status:
Vault: "+(hasVault?"exists":"missing")+"
Public keys: "+((pubJwk.enc&&pubJwk.sign)?"present":"absent")); wire(); }); }
  if(document.readyState==="loading"){ document.addEventListener("DOMContentLoaded", init); } else { init(); }
})();
</script>
</body>
</html>
