<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Filkrypto & Signering – Web Crypto (single file, lösenord + WebAuthn)</title>
  <style>
    :root { --bg:#0b1020; --fg:#e9ecf1; --muted:#aab3c0; --card:#121a33; --acc:#7aa2ff; --ok:#35d07f; --warn:#ffcc66; --err:#ff6b6b; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans"; background:linear-gradient(180deg, #0b1020, #0d1530 25%, #0d1738 60%, #0b1020); color:var(--fg); }
    header { padding: 28px 20px; text-align: center; }
    h1 { margin:0; font-size: 1.6rem; letter-spacing: .3px; }
    header p { margin:.4rem 0 0; color:var(--muted); }
    main { max-width: 1180px; margin: 0 auto; padding: 16px; display:grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 16px; }
    .card { background: rgba(18,26,51,.8); border: 1px solid rgba(255,255,255,.06); border-radius: 16px; box-shadow: 0 8px 22px rgba(0,0,0,.25); padding: 16px; backdrop-filter: blur(6px); }
    .card h2 { margin: 0 0 10px; font-size: 1.1rem; }
    .card p { color: var(--muted); margin: 6px 0 12px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: center; }
    label { font-size:.9rem; color:var(--muted); display:block; margin:.2rem 0 .4rem; }
    input[type="file"], textarea, input[type="password"], input[type="text"], select { width:100%; background:#0e1530; color:var(--fg); border:1px solid rgba(255,255,255,.08); border-radius: 10px; padding:10px 12px; font-size:.92rem; }
    textarea { min-height: 110px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .btn { appearance:none; border:1px solid rgba(255,255,255,.1); padding:10px 14px; border-radius: 12px; background: #172044; color: var(--fg); font-weight: 600; cursor: pointer; transition: transform .02s ease, background .18s ease; }
    .btn:hover { background:#1b2653; }
    .btn:active { transform: translateY(1px); }
    .btn.acc { background: #1a2d77; border-color: rgba(122, 162, 255, .45); }
    .btn.ok { background: #124b33; border-color: rgba(53,208,127,.4); }
    .btn.warn { background: #4d3a09; border-color: rgba(255,204,102,.45);} 
    .btn.err { background: #5a1e1e; border-color: rgba(255,107,107,.45);} 
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size:.85rem; color: var(--muted); }
    .status { padding:10px 12px; border-radius: 10px; background: #0d1430; border:1px dashed rgba(255,255,255,.15); color:var(--muted); margin-top: 10px; white-space: pre-wrap; word-break: break-word; }
    footer { max-width:1180px; margin:20px auto 40px; padding: 0 16px; color: var(--muted); font-size:.9rem; }
    .grid-2 { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:10px; }
    .hide { display:none; }
    .tag { display:inline-flex; gap:6px; align-items:center; padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:#0d1530; color:var(--muted); font-size:.78rem; }
    code { background:#0e1530; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.1); }
  </style>
  <!-- Rek: sätt CSP på servern
       Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'none'; frame-ancestors 'none'; upgrade-insecure-requests; -->
</head>
<body>
  <header>
    <h1>Filkryptering & Signering i webbläsaren</h1>
    <p>Web Crypto (hybrid AES‑GCM + RSA‑OAEP) och ECDSA‑signering. Privata nycklar ligger krypterade i IndexedDB och kräver <strong>lösenord</strong> och, om aktiverat, <strong>WebAuthn</strong> för att användas.</p>
  </header>

  <main>
    <section class="card" id="env">
      <h2>Miljökoll</h2>
      <div class="row" id="envTags"></div>
      <div class="status" id="envStatus">Initierar…</div>
    </section>

    <section class="card" id="vault">
      <h2>Säkerhetslås: Lösenord + WebAuthn</h2>
      <p>Ställ in ett lösenord och (valfritt) koppla en WebAuthn‑nyckel (plattform eller extern) för tvåfaktors‑upplåsning.</p>
      <div class="grid-2">
        <div>
          <label>Skapa/ändra lösenord</label>
          <input type="password" id="setPass1" placeholder="Nytt lösenord" autocomplete="new-password" />
          <input type="password" id="setPass2" placeholder="Bekräfta lösenord" autocomplete="new-password" style="margin-top:8px" />
          <div class="row" style="margin-top:8px">
            <button class="btn acc" id="setPassBtn">Spara lösenord</button>
            <button class="btn warn" id="exportVaultBtn">Exportera krypterad backup (.keyvault.json)</button>
            <input type="file" id="importVaultFile" accept="application/json" />
          </div>
        </div>
        <div>
          <label>Lås upp för sessionen</label>
          <input type="password" id="unlockPass" placeholder="Lösenord för upplåsning" autocomplete="current-password" />
          <div class="row" style="margin-top:8px">
            <select id="autoLockMins" style="max-width:180px">
              <option value="1">Auto‑lås: 1 min</option>
              <option value="5" selected>Auto‑lås: 5 min</option>
              <option value="15">Auto‑lås: 15 min</option>
              <option value="0">Ingen auto‑låsning</option>
            </select>
            <button class="btn ok" id="unlockBtn">Lås upp</button>
            <button class="btn" id="lockNowBtn">Lås nu</button>
            <button class="btn err" id="wipeBtn">Rensa nycklar</button>
          </div>
          <div class="small" id="lockState">Låsstatus: okänd</div>
        </div>
      </div>

      <hr style="border-color: rgba(255,255,255,.08); margin:14px 0" />
      <div class="grid-2">
        <div>
          <label>WebAuthn‑registrering</label>
          <select id="webauthnAttachment" style="max-width:220px">
            <option value="platform">Plattform (TouchID/Windows Hello)</option>
            <option value="cross-platform">Extern (YubiKey m.fl.)</option>
            <option value="any" selected>Valfri</option>
          </select>
          <div class="row" style="margin-top:8px">
            <button class="btn acc" id="regWebAuthnBtn">Registrera WebAuthn‑nyckel</button>
            <button class="btn" id="testWebAuthnBtn">Testa autentisering</button>
            <button class="btn err" id="removeWebAuthnBtn">Ta bort koppling</button>
          </div>
        </div>
        <div>
          <label>Policy</label>
          <div class="row">
            <label style="display:flex; align-items:center; gap:8px"><input type="checkbox" id="requireWebAuthn" /> Kräv WebAuthn vid upplåsning (2FA)</label>
          </div>
          <div class="small" id="webauthnState">WebAuthn: ej init</div>
        </div>
      </div>
      <div class="status" id="vaultStatus">—</div>
    </section>

    <section class="card" id="keys">
      <h2>Nycklar (din identitet)</h2>
      <p>Skapar <strong>kryptering</strong> (RSA‑OAEP 4096) & <strong>signering</strong> (ECDSA P‑256). Privata nycklar sparas endast krypterade i din vault.</p>
      <div class="row">
        <button class="btn acc" id="genKeys">Generera båda nyckelparen</button>
      </div>
      <div class="grid-2" style="margin-top:12px">
        <div>
          <label>Exportera <strong>publik</strong> krypteringsnyckel (JWK)</label>
          <textarea id="pubEncOut" readonly placeholder="Exportera…"></textarea>
          <div class="row" style="margin-top:8px">
            <button class="btn" id="exportPubEnc">Exportera</button>
            <button class="btn" id="downloadPubEnc">Ladda ned .pubkey.json</button>
          </div>
        </div>
        <div>
          <label>Exportera <strong>publik</strong> signeringsnyckel (JWK)</label>
          <textarea id="pubSignOut" readonly placeholder="Exportera…"></textarea>
          <div class="row" style="margin-top:8px">
            <button class="btn" id="exportPubSign">Exportera</button>
            <button class="btn" id="downloadPubSign">Ladda ned .pubsigkey.json</button>
          </div>
        </div>
      </div>
      <div class="status" id="keysStatus">—</div>
    </section>

    <section class="card" id="import">
      <h2>Importera mottagarens publika nyckel (för kryptering)</h2>
      <p>Klistra in JWK (RSA‑OAEP) eller ladda upp en .json med mottagarens <em>publika</em> nyckel.</p>
      <textarea id="theirPubJwk" placeholder='{"kty":"RSA","n":"…","e":"AQAB",…}'></textarea>
      <div class="row" style="margin-top:8px">
        <input type="file" id="theirPubFile" accept="application/json" />
        <button class="btn" id="importTheirPub">Importera nyckel</button>
      </div>
      <div class="status" id="importStatus">—</div>
    </section>

    <section class="card" id="encrypt">
      <h2>Kryptera fil för någon annan</h2>
      <p>Välj en fil. Den krypteras med en slumpad AES‑nyckel (GCM) som sedan <em>wrap:as</em> (RSA‑OAEP) med den importerade publika nyckeln.</p>
      <input type="file" id="encFile" />
      <div class="row" style="margin-top:8px">
        <button class="btn ok" id="doEncrypt">Kryptera & ladda ned .enc.json</button>
      </div>
      <div class="status" id="encStatus">—</div>
    </section>

    <section class="card" id="decrypt">
      <h2>Dekryptera fil som krypterats till dig</hh2>
      <p>Ladda upp en tidigare skapad <code>.enc.json</code>. <strong>Kräver upplåst session</strong> (lösenord och ev. WebAuthn).</p>
      <input type="file" id="decFile" accept="application/json" />
      <div class="row" style="margin-top:8px">
        <button class="btn ok" id="doDecrypt">Dekryptera & ladda ned original</button>
      </div>
      <div class="status" id="decStatus">—</div>
    </section>

    <section class="card" id="sign">
      <h2>Signera dokument</h2>
      <p>Välj fil att signera. ECDSA P‑256 används och en fristående <code>.sig.json</code> skapas. <strong>Kräver upplåst session</strong>.</p>
      <input type="file" id="signFile" />
      <div class="row" style="margin-top:8px">
        <button class="btn ok" id="doSign">Signera & ladda ned .sig.json</button>
      </div>
      <div class="status" id="signStatus">—</div>
    </section>

    <section class="card" id="verify">
      <h2>Verifiera signatur</h2>
      <p>Ladda upp originalfilen och motsvarande <code>.sig.json</code> för att verifiera.</p>
      <div class="row">
        <input type="file" id="verifyFile" />
        <input type="file" id="verifySig" accept="application/json" />
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="doVerify">Verifiera</button>
      </div>
      <div class="status" id="verifyStatus">—</div>
    </section>
  </main>

  <footer>
    <p><strong>Tips:</strong> Kör över <code>https://</code> (eller <code>http://localhost</code>). WebAuthn kräver säker kontext och användargest. Backupfilen <code>.keyvault.json</code> är krypterad med ditt lösenord – förvara det säkert.</p>
    <p class="small">Begränsning: I denna offline‑app används WebAuthn som stark lokal <em>andra faktor</em> (gate). Full kryptografisk server‑verifiering av assertions görs inte. För högsta säkerhet: kombinera med strikt CSP och hårdvarunyckel.</p>
  </footer>

<script>
(() => {
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));

  // ---- IndexedDB ----
  const dbp = new Promise((resolve, reject) => {
    const open = indexedDB.open('crypto-app-v3', 1);
    open.onupgradeneeded = () => { open.result.createObjectStore('kv'); };
    open.onsuccess = () => resolve(open.result);
    open.onerror = () => reject(open.error);
  });
  async function dbGet(key) { const db = await dbp; const tx = db.transaction('kv'); const store = tx.objectStore('kv'); return new Promise((res, rej)=>{ const req=store.get(key); req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); }); }
  async function dbSet(key, val) { const db = await dbp; const tx = db.transaction('kv','readwrite'); const store = tx.objectStore('kv'); return new Promise((res, rej)=>{ const req=store.put(val,key); req.onsuccess=()=>res(true); req.onerror=()=>rej(req.error); }); }
  async function dbDel(key) { const db = await dbp; const tx = db.transaction('kv','readwrite'); const store = tx.objectStore('kv'); return new Promise((res, rej)=>{ const req=store.delete(key); req.onsuccess=()=>res(true); req.onerror=()=>rej(req.error); }); }

  // ---- Utils ----
  const enc = new TextEncoder();
  const dec = new TextDecoder();
  const toB64 = buf => btoa(String.fromCharCode(...new Uint8Array(buf)));
  const fromB64 = b64 => Uint8Array.from(atob(b64), c => c.charCodeAt(0)).buffer;
  const toHex = buf => [...new Uint8Array(buf)].map(b => b.toString(16).padStart(2,'0')).join('');
  const toB64url = buf => toB64(buf).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  const fromB64url = str => { const pad = '='.repeat((4 - (str.length % 4)) % 4); const b64 = str.replace(/-/g,'+').replace(/_/g,'/') + pad; return fromB64(b64); };
  function download(filename, data, type='application/octet-stream') { const blob = data instanceof Blob ? data : new Blob([data], {type}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1500); }
  function downloadTextAs(name, text) { download(name, new Blob([text], {type:'application/json'}), 'application/json'); }
  function showStatus(id, msg, tone) { const el=$(id); el.textContent=msg; el.style.borderColor = tone==='ok'? 'rgba(53,208,127,.45)': tone==='warn'? 'rgba(255,204,102,.45)': tone==='err'? 'rgba(255,107,107,.45)': 'rgba(255,255,255,.15)'; el.style.color = tone==='err'? 'var(--err)' : tone==='warn'? 'var(--warn)' : tone==='ok'? 'var(--ok)' : 'var(--muted)'; }

  // ---- KDF & Vault (PBKDF2 + AES-GCM) ----
  async function deriveAesKey(password, salt, iterations) { const baseKey = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations, hash:'SHA-256'}, baseKey, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']); }
  async function encryptJSON(obj, password, iterations=250000) { const salt=crypto.getRandomValues(new Uint8Array(16)); const iv=crypto.getRandomValues(new Uint8Array(12)); const aesKey=await deriveAesKey(password, salt, iterations); const pt=enc.encode(JSON.stringify(obj)); const ct=await crypto.subtle.encrypt({name:'AES-GCM', iv}, aesKey, pt); return { version:1, createdAt:new Date().toISOString(), kdf:{name:'PBKDF2', hash:'SHA-256', iterations, salt:toB64(salt)}, enc:{algo:'AES-GCM', iv:toB64(iv), ciphertext:toB64(ct)} }; }
  async function decryptJSON(vaultObj, password) { const {kdf, enc:part}=vaultObj; const salt=new Uint8Array(fromB64(kdf.salt)); const iv=new Uint8Array(fromB64(part.iv)); const aesKey=await deriveAesKey(password, salt, kdf.iterations); const pt=await crypto.subtle.decrypt({name:'AES-GCM', iv}, aesKey, fromB64(part.ciphertext)); return JSON.parse(dec.decode(pt)); }

  // ---- Global state ----
  let unlocked=false; let autoLockTimer=null; let autoLockMinutes=5; let theirEncPubKey=null; let lastActivity=Date.now();
  let priv={ encKey:null, signKey:null }; // in-memory när upplåst
  let pubJwk={ enc:null, sign:null };
  let webauthnCred=null; // {id: b64url, userId: b64url}
  let webauthnRequired=false;

  function touchActivity(){ lastActivity=Date.now(); scheduleAutoLock(); }
  function scheduleAutoLock(){ if(autoLockTimer) clearTimeout(autoLockTimer); if(autoLockMinutes&&autoLockMinutes>0){ autoLockTimer=setTimeout(lockNow, autoLockMinutes*60*1000); } }
  function setLockStateText(){ $('#lockState').textContent=`Låsstatus: ${unlocked? 'Upplåst' : 'Låst'}${unlocked && autoLockMinutes? ` (auto‑lås om ~${autoLockMinutes} min)` : ''}${webauthnRequired? ' · 2FA (WebAuthn krävs)':''}`; }
  async function lockNow(){ priv.encKey=null; priv.signKey=null; unlocked=false; setLockStateText(); showStatus('#vaultStatus','Låst.', 'ok'); }

  // ---- Miljökoll ----
  async function ensureEnv(){
    const tags=$('#envTags'); const tag=(label,ok=true)=>{ const span=document.createElement('span'); span.className='tag'; span.style.borderColor=ok? 'rgba(122,162,255,.45)':'rgba(255,107,107,.45)'; span.innerHTML=ok? `✅ ${label}`:`⚠️ ${label}`; tags.appendChild(span); };
    const secure=window.isSecureContext; tag(secure? 'SecureContext: OK':'Kräver HTTPS/localhost', secure);
    const hasCrypto=!!(window.crypto && crypto.subtle); tag(hasCrypto? 'Web Crypto: OK':'Web Crypto: saknas', hasCrypto);
    const iDB='indexedDB' in window; tag(iDB? 'IndexedDB: OK':'IndexedDB: saknas', iDB);
    const hasWebAuthn = 'PublicKeyCredential' in window; tag(hasWebAuthn? 'WebAuthn API: OK':'WebAuthn: saknas', hasWebAuthn);
    if (hasWebAuthn && PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable) {
      try { const uv=await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable(); tag(uv? 'Plattformsnyckel: Tillgänglig':'Plattformsnyckel: Ej tillgänglig', uv); } catch {}
    }
    showStatus('#envStatus',`URL: ${location.href}\nSäker kontext: ${secure}\nWeb Crypto: ${hasCrypto}\nIndexedDB: ${iDB}`);
  }

  // ---- Nyckelhantering ----
  async function generateKeys(){
    try{
      const p1=$('#setPass1').value || $('#unlockPass').value; const p2=$('#setPass2').value || $('#unlockPass').value;
      if(!p1||p1!==p2){ showStatus('#keysStatus','Ställ in ett lösenord (två lika fält) innan generering.', 'warn'); return; }
      showStatus('#keysStatus','Genererar RSA‑OAEP 4096…');
      const encPair = await crypto.subtle.generateKey({name:'RSA-OAEP', modulusLength:4096, publicExponent:new Uint8Array([1,0,1]), hash:'SHA-256'}, true, ['encrypt','decrypt','unwrapKey']);
      showStatus('#keysStatus','Genererar ECDSA P‑256…');
      const signPair = await crypto.subtle.generateKey({name:'ECDSA', namedCurve:'P-256'}, true, ['sign','verify']);
      const [encPrivJwk, encPub, signPrivJwk, signPub] = await Promise.all([
        crypto.subtle.exportKey('jwk', encPair.privateKey),
        crypto.subtle.exportKey('jwk', encPair.publicKey),
        crypto.subtle.exportKey('jwk', signPair.privateKey),
        crypto.subtle.exportKey('jwk', signPair.publicKey)
      ]);
      pubJwk.enc = encPub; pubJwk.sign = signPub; await dbSet('pub.enc.jwk', encPub); await dbSet('pub.sign.jwk', signPub);
      const vaultPayload={ encPrivJwk, signPrivJwk };
      const vault = await encryptJSON(vaultPayload, p1);
      await dbSet('vault', vault);
      priv.encKey=null; priv.signKey=null; unlocked=false; setLockStateText();
      showStatus('#keysStatus','Klar: nycklar skapade och lagrade i krypterad vault ✔️', 'ok');
      showStatus('#vaultStatus','Vault skapad/uppdaterad. Exportera backup vid behov.', 'ok');
    }catch(e){ console.error(e); showStatus('#keysStatus','Fel vid generering: '+e.message, 'err'); }
  }

  async function exportPubEnc(){ const jwk=pubJwk.enc || await dbGet('pub.enc.jwk'); if(!jwk) return showStatus('#keysStatus','Ingen publik krypteringsnyckel – generera först.', 'warn'); $('#pubEncOut').value=JSON.stringify(jwk, null, 2); }
  async function exportPubSign(){ const jwk=pubJwk.sign || await dbGet('pub.sign.jwk'); if(!jwk) return showStatus('#keysStatus','Ingen publik signeringsnyckel – generera först.', 'warn'); $('#pubSignOut').value=JSON.stringify(jwk, null, 2); }

  // ---- Vault: lösenord ----
  async function setPassword(){
    const p1=$('#setPass1').value.trim(); const p2=$('#setPass2').value.trim(); if(!p1||p1!==p2) return showStatus('#vaultStatus','Lösenorden måste vara ifyllda och lika.', 'warn');
    const existingVault=await dbGet('vault');
    if(existingVault){
      try { const oldPass=$('#unlockPass').value || p1; const payload=await decryptJSON(existingVault, oldPass); const newVault=await encryptJSON(payload, p1); await dbSet('vault', newVault); showStatus('#vaultStatus','Lösenord uppdaterat och vault re‑krypterad.', 'ok'); }
      catch(e){ showStatus('#vaultStatus','Kunde inte uppdatera – lås upp med det gamla lösenordet först.', 'err'); return; }
    } else {
      const newVault = await encryptJSON({}, p1); await dbSet('vault', newVault); showStatus('#vaultStatus','Lösenord satt. Generera nycklar för att fylla din vault.', 'ok');
    }
  }

  async function unlockNow(){
    const pass=$('#unlockPass').value.trim(); if(!pass) return showStatus('#vaultStatus','Fyll i lösenord.', 'warn');
    try{
      const vault=await dbGet('vault'); if(!vault) return showStatus('#vaultStatus','Ingen vault hittades – skapa nycklar först.', 'warn');
      // Dekryptera först, importera senare efter ev. WebAuthn
      const payload=await decryptJSON(vault, pass);
      if(!payload.encPrivJwk||!payload.signPrivJwk) { showStatus('#vaultStatus','Vault saknar nycklar. Generera dem först.', 'warn'); return; }
      if(webauthnRequired){
        const ok = await webauthnAssert();
        if(!ok){ showStatus('#vaultStatus','WebAuthn misslyckades eller avbröts.', 'err'); return; }
      }
      // Importera privata nycklar non‑extractable
      const [encPriv, signPriv] = await Promise.all([
        crypto.subtle.importKey('jwk', payload.encPrivJwk, {name:'RSA-OAEP', hash:'SHA-256'}, false, ['decrypt','unwrapKey']),
        crypto.subtle.importKey('jwk', payload.signPrivJwk, {name:'ECDSA', namedCurve:'P-256'}, false, ['sign'])
      ]);
      priv.encKey=encPriv; priv.signKey=signPriv; unlocked=true; touchActivity(); setLockStateText();
      showStatus('#vaultStatus','Upplåst.', 'ok');
    }catch(e){ console.error(e); showStatus('#vaultStatus','Fel vid upplåsning: '+e.message, 'err'); }
  }

  function exportVault(){ dbGet('vault').then(v=>{ if(!v) return showStatus('#vaultStatus','Ingen vault att exportera.', 'warn'); downloadTextAs('keys.keyvault.json', JSON.stringify(v, null, 2)); }); }
  function importVaultFromFile(ev){ const f=ev.target.files[0]; if(!f) return; f.text().then(txt=>{ try{ const v=JSON.parse(txt); if(!v.enc||!v.kdf) throw new Error('Ogiltig vault'); dbSet('vault', v).then(()=>showStatus('#vaultStatus','Vault importerad ✔️','ok')); } catch(e){ showStatus('#vaultStatus','Fel vid import: '+e.message, 'err'); } }); }
  async function wipeAll(){ await Promise.all([dbDel('vault'), dbDel('pub.enc.jwk'), dbDel('pub.sign.jwk'), dbDel('webauthn.cred'), dbDel('webauthn.required')]); priv.encKey=null; priv.signKey=null; pubJwk={enc:null,sign:null}; webauthnCred=null; webauthnRequired=false; unlocked=false; setLockStateText(); showStatus('#vaultStatus','Allt rensat från denna webbläsare.', 'ok'); updateWebAuthnState(); }

  // ---- WebAuthn helpers ----
  async function webauthnAvailable(){ return 'PublicKeyCredential' in window; }
  function getRpId(){ try{ return location.hostname || undefined; } catch{ return undefined; } }
  async function registerWebAuthn(){
    if(!(await webauthnAvailable())){ showStatus('#vaultStatus','WebAuthn stöds ej i denna miljö.', 'err'); return; }
    try{
      const userId = crypto.getRandomValues(new Uint8Array(16));
      const challenge = crypto.getRandomValues(new Uint8Array(32));
      const attachSel = $('#webauthnAttachment').value;
      const authenticatorSelection = attachSel==='any'? { userVerification:'required' } : { userVerification:'required', authenticatorAttachment: attachSel };
      const pubKeyCredParams = [ -7, -257, -8, -259 ].map(alg=>({ type:'public-key', alg }));
      const publicKey = { challenge, rp:{ name:'Local Crypto App', id:getRpId() }, user:{ id:userId, name:'local-user', displayName:'Local User' }, pubKeyCredParams, timeout: 60000, authenticatorSelection, attestation:'none' };
      const cred = await navigator.credentials.create({ publicKey });
      const rawId = new Uint8Array(cred.rawId);
      const store = { id: toB64url(rawId), userId: toB64url(userId) };
      await dbSet('webauthn.cred', store);
      webauthnCred = store; updateWebAuthnState();
      showStatus('#vaultStatus','WebAuthn‑nyckel registrerad ✔️', 'ok');
    }catch(e){ console.error(e); showStatus('#vaultStatus','Registrering misslyckades: '+e.message, 'err'); }
  }
  async function webauthnAssert(){
    try{
      const info = webauthnCred || await dbGet('webauthn.cred'); if(!info){ showStatus('#vaultStatus','Ingen WebAuthn‑nyckel registrerad.', 'warn'); return false; }
      const challenge = crypto.getRandomValues(new Uint8Array(32));
      const allow = [{ type:'public-key', id: new Uint8Array(fromB64url(info.id)) }];
      const assertion = await navigator.credentials.get({ publicKey:{ challenge, allowCredentials: allow, userVerification:'required', timeout: 60000, rpId: getRpId() } });
      // Offline-app: vi litar på att assertionen endast ges efter UV + rätt credential.
      return !!assertion;
    }catch(e){ console.error(e); return false; }
  }
  async function testWebAuthn(){ const ok = await webauthnAssert(); showStatus('#vaultStatus', ok? 'WebAuthn‑autentisering OK ✔️' : 'WebAuthn‑autentisering misslyckades/avbröts.', ok? 'ok':'err'); }
  async function removeWebAuthn(){ await dbDel('webauthn.cred'); webauthnCred=null; showStatus('#vaultStatus','WebAuthn‑koppling borttagen.', 'ok'); updateWebAuthnState(); }
  async function toggleRequireWebAuthn(){ webauthnRequired=$('#requireWebAuthn').checked; await dbSet('webauthn.required', !!webauthnRequired); updateWebAuthnState(); }
  async function updateWebAuthnState(){
    const cred = webauthnCred || await dbGet('webauthn.cred'); const req = (await dbGet('webauthn.required')) === true || webauthnRequired;
    webauthnCred = cred || null; webauthnRequired = !!req; $('#requireWebAuthn').checked = webauthnRequired;
    $('#webauthnState').textContent = `WebAuthn: ${webauthnCred? 'registrerad ✔️' : 'inte registrerad'} · Krav: ${webauthnRequired? 'på':'av'}`;
    setLockStateText();
  }

  // ---- Import recipient public key ----
  async function importRecipientFromText(){ try{ const raw=$('#theirPubJwk').value.trim(); if(!raw) return showStatus('#importStatus','Klistra in JWK först.','warn'); const jwk=JSON.parse(raw); if(jwk.kty!=='RSA') throw new Error('Måste vara RSA JWK för RSA‑OAEP.'); theirEncPubKey = await crypto.subtle.importKey('jwk', jwk, {name:'RSA-OAEP', hash:'SHA-256'}, true, ['encrypt']); showStatus('#importStatus','Mottagarens publika nyckel importerad ✔️','ok'); } catch(e){ console.error(e); showStatus('#importStatus','Fel vid import: '+e.message,'err'); } }
  $('#theirPubFile').addEventListener('change', async e=>{ const f=e.target.files[0]; if(!f) return; try{ const txt=await f.text(); $('#theirPubJwk').value=txt; await importRecipientFromText(); } catch(e2){ showStatus('#importStatus','Fel vid fil‑läsning: '+e2.message,'err'); } });

  // ---- Encrypt / Decrypt ----
  async function encryptForRecipient(){ const file=$('#encFile').files[0]; if(!file) return showStatus('#encStatus','Välj en fil att kryptera.','warn'); if(!theirEncPubKey) return showStatus('#encStatus','Importera mottagarens publika nyckel först.','warn'); try{ showStatus('#encStatus','Läser fil…'); const data=await file.arrayBuffer(); const aesKey=await crypto.subtle.generateKey({name:'AES-GCM', length:256}, true, ['encrypt','decrypt']); const iv=crypto.getRandomValues(new Uint8Array(12)); showStatus('#encStatus','Krypterar (AES‑GCM)…'); const ciphertext=await crypto.subtle.encrypt({name:'AES-GCM', iv}, aesKey, data); showStatus('#encStatus','Wrappar AES‑nyckel (RSA‑OAEP)…'); const wrapped=await crypto.subtle.wrapKey('raw', aesKey, theirEncPubKey, {name:'RSA-OAEP'}); const pkg={ type:'hybrid-enc', encAlgo:'AES-GCM', iv:toB64(iv), wrappedKeyAlgo:'RSA-OAEP', wrappedKey:toB64(wrapped), ciphertext:toB64(ciphertext), filename:file.name, mime:file.type||'application/octet-stream', size:file.size, createdAt:new Date().toISOString() }; downloadTextAs(file.name+'.enc.json', JSON.stringify(pkg, null, 2)); showStatus('#encStatus','Klar: filen är krypterad och nedladdad ✔️','ok'); } catch(e){ console.error(e); showStatus('#encStatus','Fel vid kryptering: '+e.message,'err'); } }

  async function ensureUnlocked(opStatusId){ if(unlocked && priv.encKey && priv.signKey) return true; showStatus(opStatusId||'#vaultStatus','Åtgärden kräver upplåst session. Skriv lösenordet och klicka "Lås upp".', 'warn'); return false; }

  async function decryptForMe(){ if(!await ensureUnlocked('#decStatus')) return; const file=$('#decFile').files[0]; if(!file) return showStatus('#decStatus','Välj en .enc.json att dekryptera.','warn'); try{ const txt=await file.text(); const pkg=JSON.parse(txt); if(pkg.type!=='hybrid-enc') throw new Error('Okänt paketformat.'); const wrapped=fromB64(pkg.wrappedKey); const iv=new Uint8Array(fromB64(pkg.iv)); touchActivity(); showStatus('#decStatus','Återställer AES‑nyckel…'); const aesKey=await crypto.subtle.unwrapKey('raw', wrapped, priv.encKey, {name:'RSA-OAEP'}, {name:'AES-GCM', length:256}, true, ['decrypt']); showStatus('#decStatus','Dekrypterar (AES‑GCM)…'); const plaintext=await crypto.subtle.decrypt({name:'AES-GCM', iv}, aesKey, fromB64(pkg.ciphertext)); const outBlob=new Blob([plaintext], {type: pkg.mime||'application/octet-stream'}); const outName=(pkg.filename||'fil')+'.decrypted'; download(outName, outBlob, outBlob.type); showStatus('#decStatus','Klar: filen är dekrypterad ✔️','ok'); } catch(e){ console.error(e); showStatus('#decStatus','Fel vid dekryptering: '+e.message,'err'); } }

  // ---- Sign & Verify ----
  async function signFile(){ if(!await ensureUnlocked('#signStatus')) return; const file=$('#signFile').files[0]; if(!file) return showStatus('#signStatus','Välj en fil att signera.','warn'); try{ showStatus('#signStatus','Läser fil…'); const data=await file.arrayBuffer(); const digest=await crypto.subtle.digest('SHA-256', data); touchActivity(); showStatus('#signStatus','Signerar (ECDSA P‑256)…'); const signature=await crypto.subtle.sign({name:'ECDSA', hash:'SHA-256'}, priv.signKey, digest); const pub=pubJwk.sign || await dbGet('pub.sign.jwk'); const sigPkg={ type:'ecdsa-detached-sig', algorithm:'ECDSA-P256-SHA256', file:{ name:file.name, size:file.size, mime:file.type||'application/octet-stream' }, sha256:toHex(digest), signature:toB64(signature), publicKeyJwk: pub, createdAt:new Date().toISOString() }; downloadTextAs(file.name+'.sig.json', JSON.stringify(sigPkg, null, 2)); showStatus('#signStatus','Klar: signatur skapad ✔️','ok'); } catch(e){ console.error(e); showStatus('#signStatus','Fel vid signering: '+e.message,'err'); } }

  async function verifySig(){ try{ const f=$('#verifyFile').files[0]; const s=$('#verifySig').files[0]; if(!f||!s) return showStatus('#verifyStatus','Välj både fil och .sig.json.','warn'); const [data, sigTxt] = await Promise.all([f.arrayBuffer(), s.text()]); const sigPkg=JSON.parse(sigTxt); if(sigPkg.type!=='ecdsa-detached-sig') throw new Error('Okänt signaturformat.'); const digest=await crypto.subtle.digest('SHA-256', data); if(toHex(digest)!==sigPkg.sha256) return showStatus('#verifyStatus','Hash mismatch – fel fil?','err'); const pubKey=await crypto.subtle.importKey('jwk', sigPkg.publicKeyJwk, {name:'ECDSA', namedCurve:'P-256'}, true, ['verify']); const ok=await crypto.subtle.verify({name:'ECDSA', hash:'SHA-256'}, pubKey, fromB64(sigPkg.signature), digest); showStatus('#verifyStatus', ok? 'Signaturen är GILTIG ✔️' : 'Ogiltig signatur ✖️', ok? 'ok':'err'); } catch(e){ console.error(e); showStatus('#verifyStatus','Fel vid verifiering: '+e.message,'err'); } }

  // ---- Wire up ----
  $('#genKeys').addEventListener('click', generateKeys);
  $('#exportPubEnc').addEventListener('click', exportPubEnc);
  $('#exportPubSign').addEventListener('click', exportPubSign);
  $('#downloadPubEnc').addEventListener('click', ()=>{ const val=$('#pubEncOut').value.trim(); if(!val) return showStatus('#keysStatus','Exportera först.','warn'); downloadTextAs('public-encryption-key.pubkey.json', val); });
  $('#downloadPubSign').addEventListener('click', ()=>{ const val=$('#pubSignOut').value.trim(); if(!val) return showStatus('#keysStatus','Exportera först.','warn'); downloadTextAs('public-signing-key.pubsigkey.json', val); });

  $('#importTheirPub').addEventListener('click', importRecipientFromText);
  $('#doEncrypt').addEventListener('click', encryptForRecipient);
  $('#doDecrypt').addEventListener('click', decryptForMe);
  $('#doSign').addEventListener('click', signFile);
  $('#doVerify').addEventListener('click', verifySig);

  $('#setPassBtn').addEventListener('click', setPassword);
  $('#unlockBtn').addEventListener('click', ()=>{ autoLockMinutes=parseInt($('#autoLockMins').value,10); unlockNow(); });
  $('#lockNowBtn').addEventListener('click', lockNow);
  $('#wipeBtn').addEventListener('click', wipeAll);
  $('#exportVaultBtn').addEventListener('click', exportVault);
  $('#importVaultFile').addEventListener('change', importVaultFromFile);

  $('#regWebAuthnBtn').addEventListener('click', registerWebAuthn);
  $('#testWebAuthnBtn').addEventListener('click', testWebAuthn);
  $('#removeWebAuthnBtn').addEventListener('click', removeWebAuthn);
  $('#requireWebAuthn').addEventListener('change', toggleRequireWebAuthn);

  document.addEventListener('click', touchActivity); document.addEventListener('keydown', touchActivity);

  // ---- Init ----
  (async()=>{
    await ensureEnv();
    pubJwk.enc = await dbGet('pub.enc.jwk'); pubJwk.sign = await dbGet('pub.sign.jwk');
    webauthnCred = await dbGet('webauthn.cred'); webauthnRequired = (await dbGet('webauthn.required'))===true;
    const hasVault=!!(await dbGet('vault'));
    setLockStateText();
    updateWebAuthnState();
    showStatus('#keysStatus',`Nyckelstatus:\n- Vault: ${hasVault? 'finns ✔️':'saknas'}\n- Publika nycklar: ${(pubJwk.enc&&pubJwk.sign)? 'finns ✔️':'saknas'}`);
  })();
})();
</script>
</body>
</html>
