<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Filkrypto & Signering ‚Äì Web Crypto (l√∂senord + WebAuthn)</title>
  <style>
    :root { --bg:#0b1020; --fg:#e9ecf1; --muted:#aab3c0; --card:#121a33; --acc:#7aa2ff; --ok:#35d07f; --warn:#ffcc66; --err:#ff6b6b; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans"; background:#0b1020; color:var(--fg); }
    header { padding: 20px; text-align: center; background:#121a33; position:sticky; top:0; z-index:100; }
    h1 { margin:0; font-size: 1.4rem; }
    nav { margin-top:10px; display:flex; flex-wrap:wrap; justify-content:center; gap:8px; }
    nav button { background:#172044; border:1px solid rgba(255,255,255,.1); color:var(--fg); padding:8px 12px; border-radius:8px; cursor:pointer; }
    nav button.active { background:#1a2d77; border-color:rgba(122,162,255,.45); }
    main { max-width: 1000px; margin: 0 auto; padding: 16px; }
    .card { background: rgba(18,26,51,.85); border: 1px solid rgba(255,255,255,.06); border-radius: 16px; box-shadow: 0 8px 22px rgba(0,0,0,.25); padding: 16px; backdrop-filter: blur(6px); margin-bottom:20px; }
    .card h2 { margin: 0 0 10px; font-size: 1.1rem; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: center; }
    textarea, input[type="password"], input[type="file"], select { width:100%; background:#0e1530; color:var(--fg); border:1px solid rgba(255,255,255,.08); border-radius: 10px; padding:8px 10px; font-size:.9rem; }
    .btn { padding:8px 12px; border-radius:8px; border:1px solid rgba(255,255,255,.1); background:#172044; color:var(--fg); cursor:pointer; }
    .btn.acc{ background:#1a2d77; }
    .btn.ok{ background:#124b33; }
    .btn.err{ background:#5a1e1e; }
    .status { margin-top:8px; font-size:.85rem; white-space:pre-wrap; color:var(--muted); }
    footer { max-width:1000px; margin:20px auto; padding:0 16px; font-size:.85rem; color:var(--muted); }
    section { display:none; }
    section.active { display:block; }
  .tabs{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:14px}
    .tab-btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:#0d1530;color:var(--fg);padding:8px 12px;border-radius:999px;cursor:pointer;font-weight:600}
    .tab-btn.active{background:#1a2d77;border-color:rgba(122,162,255,.45)}
    .section{display:none}
    .section.active{display:block}
  </style>
</head>
<body>
  <header>
    <h1>Filkryptering & Signering i webbl√§saren</h1>
    <p>Web Crypto (hybrid AES‚ÄëGCM + RSA‚ÄëOAEP) och ECDSA‚Äësignering. Privata nycklar ligger krypterade i IndexedDB och kr√§ver <strong>l√∂senord</strong> och, om aktiverat, <strong>WebAuthn</strong> f√∂r att anv√§ndas.</p>
    <nav class="tabs" aria-label="Sektioner">
      <button class="tab-btn active" data-target="vault">üîê L√•s & WebAuthn</button>
      <button class="tab-btn" data-target="keys">üîë Nycklar</button>
      <button class="tab-btn" data-target="import">üì• Importera publik nyckel</button>
      <button class="tab-btn" data-target="encrypt">üß© Kryptera</button>
      <button class="tab-btn" data-target="decrypt">üóùÔ∏è Dekryptera</button>
      <button class="tab-btn" data-target="sign">‚úçÔ∏è Signera</button>
      <button class="tab-btn" data-target="verify">‚úÖ Verifiera</button>
      <button class="tab-btn" data-target="env" style="margin-left:auto">‚öôÔ∏è Milj√∂</button>
    </nav>
  </header>

  <main>
    <section class="card section" id="env" data-section>
      <h2>Milj√∂koll</h2>
      <div class="row" id="envTags"></div>
      <div class="status" id="envStatus">Initierar‚Ä¶</div>
    </section>

    <section class="card section active" id="vault" data-section>
      <h2>S√§kerhetsl√•s: L√∂senord + WebAuthn</h2>
      <p>St√§ll in ett l√∂senord och (valfritt) koppla en WebAuthn‚Äënyckel (plattform eller extern) f√∂r tv√•faktors‚Äëuppl√•sning.</p>
      <div class="grid-2">
        <div>
          <label>Skapa/√§ndra l√∂senord</label>
          <input type="password" id="setPass1" placeholder="Nytt l√∂senord" autocomplete="new-password" />
          <input type="password" id="setPass2" placeholder="Bekr√§fta l√∂senord" autocomplete="new-password" style="margin-top:8px" />
          <div class="row" style="margin-top:8px">
            <button class="btn acc" id="setPassBtn">Spara l√∂senord</button>
            <button class="btn warn" id="exportVaultBtn">Exportera krypterad backup (.keyvault.json)</button>
            <input type="file" id="importVaultFile" accept="application/json" />
          </div>
        </div>
        <div>
          <label>L√•s upp f√∂r sessionen</label>
          <input type="password" id="unlockPass" placeholder="L√∂senord f√∂r uppl√•sning" autocomplete="current-password" />
          <div class="row" style="margin-top:8px">
            <select id="autoLockMins" style="max-width:180px">
              <option value="1">Auto‚Äël√•s: 1 min</option>
              <option value="5" selected>Auto‚Äël√•s: 5 min</option>
              <option value="15">Auto‚Äël√•s: 15 min</option>
              <option value="0">Ingen auto‚Äël√•sning</option>
            </select>
            <button class="btn ok" id="unlockBtn">L√•s upp</button>
            <button class="btn" id="lockNowBtn">L√•s nu</button>
            <button class="btn err" id="wipeBtn">Rensa nycklar</button>
          </div>
          <div class="small" id="lockState">L√•sstatus: ok√§nd</div>
        </div>
      </div>

      <hr style="border-color: rgba(255,255,255,.08); margin:14px 0" />
      <div class="grid-2">
        <div>
          <label>WebAuthn‚Äëregistrering</label>
          <select id="webauthnAttachment" style="max-width:220px">
            <option value="platform">Plattform (TouchID/Windows Hello)</option>
            <option value="cross-platform">Extern (YubiKey m.fl.)</option>
            <option value="any" selected>Valfri</option>
          </select>
          <div class="row" style="margin-top:8px">
            <button class="btn acc" id="regWebAuthnBtn">Registrera WebAuthn‚Äënyckel</button>
            <button class="btn" id="testWebAuthnBtn">Testa autentisering</button>
            <button class="btn err" id="removeWebAuthnBtn">Ta bort koppling</button>
          </div>
        </div>
        <div>
          <label>Policy</label>
          <div class="row">
            <label style="display:flex; align-items:center; gap:8px"><input type="checkbox" id="requireWebAuthn" /> Kr√§v WebAuthn vid uppl√•sning (2FA)</label>
          </div>
          <div class="small" id="webauthnState">WebAuthn: ej init</div>
        </div>
      </div>
      <div class="status" id="vaultStatus">‚Äî</div>
    </section>

    <section class="card section" id="keys" data-section>
      <h2>Nycklar (din identitet)</h2>
      <p>Skapar <strong>kryptering</strong> (RSA‚ÄëOAEP 4096) & <strong>signering</strong> (ECDSA P‚Äë256). Privata nycklar sparas endast krypterade i din vault.</p>
      <div class="row">
        <button class="btn acc" id="genKeys">Generera b√•da nyckelparen</button>
      </div>
      <div class="grid-2" style="margin-top:12px">
        <div>
          <label>Exportera <strong>publik</strong> krypteringsnyckel (JWK)</label>
          <textarea id="pubEncOut" readonly placeholder="Exportera‚Ä¶"></textarea>
          <div class="row" style="margin-top:8px">
            <button class="btn" id="exportPubEnc">Exportera</button>
            <button class="btn" id="downloadPubEnc">Ladda ned .pubkey.json</button>
          </div>
        </div>
        <div>
          <label>Exportera <strong>publik</strong> signeringsnyckel (JWK)</label>
          <textarea id="pubSignOut" readonly placeholder="Exportera‚Ä¶"></textarea>
          <div class="row" style="margin-top:8px">
            <button class="btn" id="exportPubSign">Exportera</button>
            <button class="btn" id="downloadPubSign">Ladda ned .pubsigkey.json</button>
          </div>
        </div>
      </div>
      <div class="status" id="keysStatus">‚Äî</div>
    </section>

    <section class="card section" id="import" data-section>
      <h2>Importera mottagarens publika nyckel (f√∂r kryptering)</h2>
      <p>Klistra in JWK (RSA‚ÄëOAEP) eller ladda upp en .json med mottagarens <em>publika</em> nyckel.</p>
      <textarea id="theirPubJwk" placeholder='{"kty":"RSA","n":"‚Ä¶","e":"AQAB",‚Ä¶}'></textarea>
      <div class="row" style="margin-top:8px">
        <input type="file" id="theirPubFile" accept="application/json" />
        <button class="btn" id="importTheirPub">Importera nyckel</button>
      </div>
      <div class="status" id="importStatus">‚Äî</div>
    </section>

    <section class="card section" id="encrypt" data-section>
      <h2>Kryptera fil f√∂r n√•gon annan</h2>
      <p>V√§lj en fil. Den krypteras med en slumpad AES‚Äënyckel (GCM) som sedan <em>wrap:as</em> (RSA‚ÄëOAEP) med den importerade publika nyckeln.</p>
      <input type="file" id="encFile" />
      <div class="row" style="margin-top:8px">
        <button class="btn ok" id="doEncrypt">Kryptera & ladda ned .enc.json</button>
      </div>
      <div class="status" id="encStatus">‚Äî</div>
    </section>

    <section class="card section" id="decrypt" data-section>
      <h2>Dekryptera fil som krypterats till dig</h2>
      <p>Ladda upp en tidigare skapad <code>.enc.json</code>. <strong>Kr√§ver uppl√•st session</strong> (l√∂senord och ev. WebAuthn).</p>
      <input type="file" id="decFile" accept="application/json" />
      <div class="row" style="margin-top:8px">
        <button class="btn ok" id="doDecrypt">Dekryptera & ladda ned original</button>
      </div>
      <div class="status" id="decStatus">‚Äî</div>
    </section>

    <section class="card section" id="sign" data-section>
      <h2>Signera dokument</h2>
      <p>V√§lj fil att signera. ECDSA P‚Äë256 anv√§nds och en frist√•ende <code>.sig.json</code> skapas. <strong>Kr√§ver uppl√•st session</strong>.</p>
      <input type="file" id="signFile" />
      <div class="row" style="margin-top:8px">
        <button class="btn ok" id="doSign">Signera & ladda ned .sig.json</button>
      </div>
      <div class="status" id="signStatus">‚Äî</div>
    </section>

    <section class="card section" id="verify" data-section>
      <h2>Verifiera signatur</h2>
      <p>Ladda upp originalfilen och motsvarande <code>.sig.json</code> f√∂r att verifiera.</p>
      <div class="row">
        <input type="file" id="verifyFile" />
        <input type="file" id="verifySig" accept="application/json" />
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="doVerify">Verifiera</button>
      </div>
      <div class="status" id="verifyStatus">‚Äî</div>
    </section>
  </main>

  <footer>
    <p><strong>Tips:</strong> K√∂r √∂ver <code>https://</code> (eller <code>http://localhost</code>). WebAuthn kr√§ver s√§ker kontext och anv√§ndargest. Backupfilen <code>.keyvault.json</code> √§r krypterad med ditt l√∂senord ‚Äì f√∂rvara det s√§kert.</p>
    <p class="small">Begr√§nsning: I denna offline‚Äëapp anv√§nds WebAuthn som stark lokal <em>andra faktor</em> (gate). Full kryptografisk server‚Äëverifiering av assertions g√∂rs inte. F√∂r h√∂gsta s√§kerhet: kombinera med strikt CSP och h√•rdvarunyckel.</p>
    <p class="small">Version <span id="appVersion"></span></p>
  </footer>

<script>
// ===== Single-file App Bootstrap & Diagnostics =====
(function(){
  var APP_VERSION = 'v1.5.0 (2025-09-03)';
  window.__APP_VERSION__ = APP_VERSION;
  function setVersion(){ var el=document.getElementById('appVersion'); if(el) el.textContent = APP_VERSION; }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', setVersion); } else { setVersion(); }
  function panic(msg){ try{ var el=document.getElementById('envStatus'); if(el){ el.textContent='Fel: '+msg; el.style.color='var(--err)'; el.style.borderColor='rgba(255,107,107,.45)'; } }catch(e){} }
  window.addEventListener('error', function(e){ panic(e.message||String(e)); });
  window.addEventListener('unhandledrejection', function(e){ var r=e.reason||{}; panic(r.message? r.message : String(r)); });

  // Tabs
  function showSection(id){
    var secs=document.querySelectorAll('[data-section]'); for(var i=0;i<secs.length;i++){ secs[i].classList.toggle('active', secs[i].id===id); }
    var btns=document.querySelectorAll('.tab-btn'); for(var j=0;j<btns.length;j++){ btns[j].classList.toggle('active', btns[j].getAttribute('data-target')===id); }
    try{ history.replaceState(null,'','#'+id);}catch(e){}
  }
  function initTabs(){
    var nav=document.querySelector('nav.tabs'); if(nav){
      nav.addEventListener('click', function(ev){ var btn=ev.target.closest('.tab-btn'); if(!btn) return; var id=btn.getAttribute('data-target'); if(!id) return; showSection(id); });
    }
    var start=(location.hash && location.hash.slice(1)) || 'vault'; if(!document.getElementById(start)) start='vault'; showSection(start);
    window.addEventListener('hashchange', function(){ var id=location.hash.slice(1); if(document.getElementById(id)) showSection(id); });
  }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', initTabs); } else { initTabs(); }
})();
</script>

<script>
// ===== Core App (Web Crypto + Vault + WebAuthn) =====
(function(){
  // ---- IndexedDB ----
  var dbp = new Promise(function(resolve, reject){ var open=indexedDB.open('crypto-app-v4',1); open.onupgradeneeded=function(){ open.result.createObjectStore('kv'); }; open.onsuccess=function(){ resolve(open.result); }; open.onerror=function(){ reject(open.error); }; });
  function dbGet(key){ return dbp.then(function(db){ return new Promise(function(res,rej){ var tx=db.transaction('kv'); var st=tx.objectStore('kv'); var req=st.get(key); req.onsuccess=function(){ res(req.result); }; req.onerror=function(){ rej(req.error); }; }); }); }
  function dbSet(key,val){ return dbp.then(function(db){ return new Promise(function(res,rej){ var tx=db.transaction('kv','readwrite'); var st=tx.objectStore('kv'); var req=st.put(val,key); req.onsuccess=function(){ res(true); }; req.onerror=function(){ rej(req.error); }; }); }); }
  function dbDel(key){ return dbp.then(function(db){ return new Promise(function(res,rej){ var tx=db.transaction('kv','readwrite'); var st=tx.objectStore('kv'); var req=st.delete(key); req.onsuccess=function(){ res(true); }; req.onerror=function(){ rej(req.error); }; }); }); }

  // ---- Utils ----
  var te = new TextEncoder(); var td = new TextDecoder();
  function toB64(buf){ return btoa(String.fromCharCode.apply(null, new Uint8Array(buf))); }
  function fromB64(b64){ return Uint8Array.from(atob(b64), function(c){ return c.charCodeAt(0); }).buffer; }
  function toHex(buf){ var a=new Uint8Array(buf); var s=''; for(var i=0;i<a.length;i++){ var h=a[i].toString(16); if(h.length<2) h='0'+h; s+=h; } return s; }
  function toB64url(buf){ return toB64(buf).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }
  function fromB64url(str){ var pad='='.repeat((4-(str.length%4))%4); var b64=str.replace(/-/g,'+').replace(/_/g,'/')+pad; return fromB64(b64); }
  function download(name, data, type){ var blob=(data instanceof Blob)? data : new Blob([data],{type:type||'application/octet-stream'}); var url=URL.createObjectURL(blob); var a=document.createElement('a'); a.href=url; a.download=name; a.click(); setTimeout(function(){ URL.revokeObjectURL(url); },1500); }
  function downloadJSON(name, obj){ download(name, new Blob([JSON.stringify(obj,null,2)],{type:'application/json'}), 'application/json'); }
  function showStatus(sel, msg, tone){ var el=document.querySelector(sel); if(!el) return; el.textContent=msg; el.style.borderColor = tone==='ok'? 'rgba(53,208,127,.45)' : tone==='warn'? 'rgba(255,204,102,.45)' : tone==='err'? 'rgba(255,107,107,.45)' : 'rgba(255,255,255,.15)'; el.style.color = tone==='err'? 'var(--err)' : tone==='warn'? 'var(--warn)' : tone==='ok'? 'var(--ok)' : 'var(--muted)'; }

  // ---- KDF & Vault (PBKDF2 + AES-GCM) ----
  function deriveAesKey(password, salt, iterations){ return crypto.subtle.importKey('raw', te.encode(password), {name:'PBKDF2'}, false, ['deriveKey']).then(function(baseKey){ return crypto.subtle.deriveKey({name:'PBKDF2', salt:salt, iterations:iterations, hash:'SHA-256'}, baseKey, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']); }); }
  function encryptJSON(obj, password, iterations){ iterations = iterations||250000; var salt=crypto.getRandomValues(new Uint8Array(16)); var iv=crypto.getRandomValues(new Uint8Array(12)); return deriveAesKey(password, salt, iterations).then(function(aesKey){ var pt=te.encode(JSON.stringify(obj)); return crypto.subtle.encrypt({name:'AES-GCM', iv:iv}, aesKey, pt).then(function(ct){ return {version:1, createdAt:new Date().toISOString(), kdf:{name:'PBKDF2', hash:'SHA-256', iterations:iterations, salt:toB64(salt)}, enc:{algo:'AES-GCM', iv:toB64(iv), ciphertext:toB64(ct)}}; }); }); }
  function decryptJSON(vaultObj, password){ var kdf=vaultObj.kdf; var part=vaultObj.enc; var salt=new Uint8Array(fromB64(kdf.salt)); var iv=new Uint8Array(fromB64(part.iv)); return deriveAesKey(password, salt, kdf.iterations).then(function(aesKey){ return crypto.subtle.decrypt({name:'AES-GCM', iv:iv}, aesKey, fromB64(part.ciphertext)); }).then(function(pt){ return JSON.parse(td.decode(pt)); }); }

  // ---- Global state ----
  var unlocked=false, autoLockTimer=null, autoLockMinutes=5, lastActivity=Date.now();
  var theirEncPubKey=null; var priv={ encKey:null, signKey:null }; var pubJwk={ enc:null, sign:null };
  var webauthnCred=null; var webauthnRequired=false;
  function touch(){ lastActivity=Date.now(); scheduleAutoLock(); }
  function scheduleAutoLock(){ if(autoLockTimer) clearTimeout(autoLockTimer); if(autoLockMinutes && autoLockMinutes>0){ autoLockTimer=setTimeout(lockNow, autoLockMinutes*60*1000); } }
  function setLockState(){ var s=document.getElementById('lockState'); if(!s) return; s.textContent = 'L√•sstatus: '+(unlocked? 'Uppl√•st':'L√•st') + (unlocked && autoLockMinutes? ' (auto‚Äël√•s om ~'+autoLockMinutes+' min)' : '') + (webauthnRequired? ' ¬∑ 2FA (WebAuthn kr√§vs)':''); }
  function lockNow(){ priv.encKey=null; priv.signKey=null; unlocked=false; setLockState(); showStatus('#vaultStatus','L√•st.','ok'); }

  // ---- Milj√∂koll ----
  function ensureEnv(){
    try{
      var tags=document.getElementById('envTags'); var secure=window.isSecureContext; var hasCrypto=!!(window.crypto && crypto.subtle); var iDB='indexedDB' in window; var hasWebAuthn=('PublicKeyCredential' in window);
      function tag(label, ok){ var span=document.createElement('span'); span.className='tag'; span.style.borderColor = ok? 'rgba(122,162,255,.45)':'rgba(255,107,107,.45)'; span.innerHTML = (ok? '‚úÖ ':'‚ö†Ô∏è ')+label; tags && tags.appendChild(span); }
      tag(secure? 'SecureContext: OK':'Kr√§ver HTTPS/localhost', secure);
      tag(hasCrypto? 'Web Crypto: OK':'Web Crypto: saknas', hasCrypto);
      tag(iDB? 'IndexedDB: OK':'IndexedDB: saknas', iDB);
      tag(hasWebAuthn? 'WebAuthn API: OK':'WebAuthn: saknas', hasWebAuthn);
      if (hasWebAuthn && PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable){
        PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().then(function(uv){ tag(uv? 'Plattformsnyckel: Tillg√§nglig':'Plattformsnyckel: Ej tillg√§nglig', uv); });
      }
      showStatus('#envStatus','URL: '+location.href+'
S√§ker kontext: '+secure+'
Web Crypto: '+hasCrypto+'
IndexedDB: '+iDB);
    }catch(e){ showStatus('#envStatus','Fel i milj√∂koll: '+e.message,'err'); }
  }

  // ---- Nyckelhantering ----
  function generateKeys(){
    var p1=document.getElementById('setPass1').value || document.getElementById('unlockPass').value;
    var p2=document.getElementById('setPass2').value || document.getElementById('unlockPass').value;
    if(!p1 || p1!==p2){ showStatus('#keysStatus','St√§ll in ett l√∂senord (tv√• lika f√§lt) innan generering.','warn'); return; }
    showStatus('#keysStatus','Genererar RSA‚ÄëOAEP 4096‚Ä¶');
    crypto.subtle.generateKey({name:'RSA-OAEP', modulusLength:4096, publicExponent:new Uint8Array([1,0,1]), hash:'SHA-256'}, true, ['encrypt','decrypt','unwrapKey']).then(function(encPair){
      showStatus('#keysStatus','Genererar ECDSA P‚Äë256‚Ä¶');
      crypto.subtle.generateKey({name:'ECDSA', namedCurve:'P-256'}, true, ['sign','verify']).then(function(signPair){
        Promise.all([
          crypto.subtle.exportKey('jwk', encPair.privateKey),
          crypto.subtle.exportKey('jwk', encPair.publicKey),
          crypto.subtle.exportKey('jwk', signPair.privateKey),
          crypto.subtle.exportKey('jwk', signPair.publicKey)
        ]).then(function(arr){
          var encPrivJwk=arr[0], encPub=arr[1], signPrivJwk=arr[2], signPub=arr[3];
          pubJwk.enc=encPub; pubJwk.sign=signPub; dbSet('pub.enc.jwk', encPub); dbSet('pub.sign.jwk', signPub);
          encryptJSON({encPrivJwk:encPrivJwk, signPrivJwk:signPrivJwk}, p1).then(function(vault){ dbSet('vault', vault).then(function(){
            priv.encKey=null; priv.signKey=null; unlocked=false; setLockState();
            showStatus('#keysStatus','Klar: nycklar skapade och lagrade i krypterad vault ‚úîÔ∏è','ok');
            showStatus('#vaultStatus','Vault skapad/uppdaterad. Exportera backup vid behov.','ok');
          }); });
        });
      });
    }).catch(function(e){ showStatus('#keysStatus','Fel vid generering: '+e.message,'err'); });
  }
  function exportPubEnc(){ (pubJwk.enc? Promise.resolve(pubJwk.enc) : dbGet('pub.enc.jwk')).then(function(jwk){ if(!jwk) return showStatus('#keysStatus','Ingen publik krypteringsnyckel ‚Äì generera f√∂rst.','warn'); document.getElementById('pubEncOut').value = JSON.stringify(jwk, null, 2); }); }
  function exportPubSign(){ (pubJwk.sign? Promise.resolve(pubJwk.sign) : dbGet('pub.sign.jwk')).then(function(jwk){ if(!jwk) return showStatus('#keysStatus','Ingen publik signeringsnyckel ‚Äì generera f√∂rst.','warn'); document.getElementById('pubSignOut').value = JSON.stringify(jwk, null, 2); }); }

  // ---- Vault: l√∂senord ----
  function setPassword(){
    var p1=document.getElementById('setPass1').value.trim(); var p2=document.getElementById('setPass2').value.trim(); if(!p1||p1!==p2){ showStatus('#vaultStatus','L√∂senorden m√•ste vara ifyllda och lika.','warn'); return; }
    dbGet('vault').then(function(existing){ if(existing){
      var oldPass=document.getElementById('unlockPass').value || p1; decryptJSON(existing, oldPass).then(function(payload){ encryptJSON(payload, p1).then(function(newVault){ dbSet('vault', newVault).then(function(){ showStatus('#vaultStatus','L√∂senord uppdaterat och vault re‚Äëkrypterad.','ok'); }); }); }).catch(function(){ showStatus('#vaultStatus','Kunde inte uppdatera ‚Äì l√•s upp med det gamla l√∂senordet f√∂rst.','err'); });
    } else { encryptJSON({}, p1).then(function(newVault){ dbSet('vault', newVault).then(function(){ showStatus('#vaultStatus','L√∂senord satt. Generera nycklar f√∂r att fylla din vault.','ok'); }); }); } });
  }
  function unlockNow(){
    var pass=document.getElementById('unlockPass').value.trim(); if(!pass){ showStatus('#vaultStatus','Fyll i l√∂senord.','warn'); return; }
    dbGet('vault').then(function(vault){ if(!vault) return showStatus('#vaultStatus','Ingen vault hittades ‚Äì skapa nycklar f√∂rst.','warn'); decryptJSON(vault, pass).then(function(payload){ if(!payload.encPrivJwk||!payload.signPrivJwk) return showStatus('#vaultStatus','Vault saknar nycklar. Generera dem f√∂rst.','warn');
      function importKeys(){ Promise.all([
        crypto.subtle.importKey('jwk', payload.encPrivJwk, {name:'RSA-OAEP', hash:'SHA-256'}, false, ['decrypt','unwrapKey']),
        crypto.subtle.importKey('jwk', payload.signPrivJwk, {name:'ECDSA', namedCurve:'P-256'}, false, ['sign'])
      ]).then(function(k){ priv.encKey=k[0]; priv.signKey=k[1]; unlocked=true; touch(); setLockState(); showStatus('#vaultStatus','Uppl√•st.','ok'); }); }
      if(webauthnRequired){ webauthnAssert().then(function(ok){ if(ok) importKeys(); else showStatus('#vaultStatus','WebAuthn misslyckades eller avbr√∂ts.','err'); }); } else { importKeys(); }
    }).catch(function(e){ showStatus('#vaultStatus','Fel vid uppl√•sning: '+e.message,'err'); }); });
  }
  function exportVault(){ dbGet('vault').then(function(v){ if(!v) return showStatus('#vaultStatus','Ingen vault att exportera.','warn'); downloadJSON('keys.keyvault.json', v); }); }
  function importVaultFromFile(ev){ var f=ev.target.files[0]; if(!f) return; f.text().then(function(txt){ try{ var v=JSON.parse(txt); if(!v.enc||!v.kdf) throw new Error('Ogiltig vault'); dbSet('vault', v).then(function(){ showStatus('#vaultStatus','Vault importerad ‚úîÔ∏è','ok'); }); } catch(e){ showStatus('#vaultStatus','Fel vid import: '+e.message,'err'); } }); }
  function wipeAll(){ Promise.all([dbDel('vault'), dbDel('pub.enc.jwk'), dbDel('pub.sign.jwk'), dbDel('webauthn.cred'), dbDel('webauthn.required')]).then(function(){ priv.encKey=null; priv.signKey=null; pubJwk={enc:null,sign:null}; webauthnCred=null; webauthnRequired=false; unlocked=false; setLockState(); showStatus('#vaultStatus','Allt rensat fr√•n denna webbl√§sare.','ok'); updateWebAuthnState(); }); }

  // ---- WebAuthn helpers ----
  function webauthnAvailable(){ return ('PublicKeyCredential' in window); }
  function getRpId(){ try{ return location.hostname || undefined; } catch(e){ return undefined; } }
  function registerWebAuthn(){ if(!webauthnAvailable()) return showStatus('#vaultStatus','WebAuthn st√∂ds ej i denna milj√∂.','err');
    try{
      var userId = crypto.getRandomValues(new Uint8Array(16)); var challenge = crypto.getRandomValues(new Uint8Array(32));
      var attachSel = document.getElementById('webauthnAttachment').value; var authSel = attachSel==='any'? { userVerification:'required' } : { userVerification:'required', authenticatorAttachment: attachSel };
      var algs=[-7,-257,-8,-259].map(function(a){ return {type:'public-key', alg:a}; });
      var publicKey={ challenge:challenge, rp:{name:'Local Crypto App', id:getRpId()}, user:{ id:userId, name:'local-user', displayName:'Local User' }, pubKeyCredParams:algs, timeout:60000, authenticatorSelection:authSel, attestation:'none' };
      navigator.credentials.create({ publicKey: publicKey }).then(function(cred){ var rawId=new Uint8Array(cred.rawId); var store={ id: toB64url(rawId), userId: toB64url(userId) }; dbSet('webauthn.cred', store).then(function(){ webauthnCred=store; updateWebAuthnState(); showStatus('#vaultStatus','WebAuthn‚Äënyckel registrerad ‚úîÔ∏è','ok'); }); }).catch(function(e){ showStatus('#vaultStatus','Registrering misslyckades: '+e.message,'err'); });
    }catch(e){ showStatus('#vaultStatus','Registrering misslyckades: '+e.message,'err'); }
  }
  function webauthnAssert(){ return new Promise(function(resolve){ try{ var info=webauthnCred; var p=(info? Promise.resolve(info) : dbGet('webauthn.cred')); p.then(function(i){ if(!i) return resolve(false); var challenge=crypto.getRandomValues(new Uint8Array(32)); var allow=[{ type:'public-key', id:new Uint8Array(fromB64url(i.id)) }]; navigator.credentials.get({ publicKey:{ challenge:challenge, allowCredentials:allow, userVerification:'required', timeout:60000, rpId:getRpId() } }).then(function(assertion){ resolve(!!assertion); }).catch(function(){ resolve(false); }); }); }catch(e){ resolve(false); } }); }
  function testWebAuthn(){ webauthnAssert().then(function(ok){ showStatus('#vaultStatus', ok? 'WebAuthn‚Äëautentisering OK ‚úîÔ∏è' : 'WebAuthn‚Äëautentisering misslyckades/avbr√∂ts.', ok? 'ok':'err'); }); }
  function removeWebAuthn(){ dbDel('webauthn.cred').then(function(){ webauthnCred=null; showStatus('#vaultStatus','WebAuthn‚Äëkoppling borttagen.','ok'); updateWebAuthnState(); }); }
  function toggleRequireWebAuthn(){ webauthnRequired = !!document.getElementById('requireWebAuthn').checked; dbSet('webauthn.required', webauthnRequired).then(updateWebAuthnState); }
  function updateWebAuthnState(){ Promise.all([ dbGet('webauthn.cred'), dbGet('webauthn.required') ]).then(function(arr){ var cred=arr[0]; var req=arr[1]===true || webauthnRequired; webauthnCred=cred||null; webauthnRequired=!!req; var lab=document.getElementById('webauthnState'); if(lab) lab.textContent = 'WebAuthn: '+(webauthnCred? 'registrerad ‚úîÔ∏è':'inte registrerad')+' ¬∑ Krav: '+(webauthnRequired? 'p√•':'av'); var cb=document.getElementById('requireWebAuthn'); if(cb) cb.checked = webauthnRequired; setLockState(); }); }

  // ---- Import recipient public key ----
  function importRecipientFromText(){ try{ var raw=document.getElementById('theirPubJwk').value.trim(); if(!raw) return showStatus('#importStatus','Klistra in JWK f√∂rst.','warn'); var jwk=JSON.parse(raw); if(jwk.kty!=='RSA') throw new Error('M√•ste vara RSA JWK f√∂r RSA‚ÄëOAEP.'); crypto.subtle.importKey('jwk', jwk, {name:'RSA-OAEP', hash:'SHA-256'}, true, ['encrypt']).then(function(k){ theirEncPubKey=k; showStatus('#importStatus','Mottagarens publika nyckel importerad ‚úîÔ∏è','ok'); }); } catch(e){ showStatus('#importStatus','Fel vid import: '+e.message,'err'); } }
  function theirPubFileChanged(e){ var f=e.target.files[0]; if(!f) return; f.text().then(function(txt){ document.getElementById('theirPubJwk').value=txt; importRecipientFromText(); }).catch(function(e2){ showStatus('#importStatus','Fel vid fil‚Äël√§sning: '+e2.message,'err'); }); }

  // ---- Encrypt / Decrypt ----
  function encryptForRecipient(){ var file=document.getElementById('encFile').files[0]; if(!file) return showStatus('#encStatus','V√§lj en fil att kryptera.','warn'); if(!theirEncPubKey) return showStatus('#encStatus','Importera mottagarens publika nyckel f√∂rst.','warn');
    showStatus('#encStatus','L√§ser fil‚Ä¶'); file.arrayBuffer().then(function(data){ crypto.subtle.generateKey({name:'AES-GCM', length:256}, true, ['encrypt','decrypt']).then(function(aesKey){ var iv=crypto.getRandomValues(new Uint8Array(12)); showStatus('#encStatus','Krypterar (AES‚ÄëGCM)‚Ä¶'); crypto.subtle.encrypt({name:'AES-GCM', iv:iv}, aesKey, data).then(function(ct){ showStatus('#encStatus','Wrappar AES‚Äënyckel (RSA‚ÄëOAEP)‚Ä¶'); crypto.subtle.wrapKey('raw', aesKey, theirEncPubKey, {name:'RSA-OAEP'}).then(function(wrapped){ var pkg={ type:'hybrid-enc', encAlgo:'AES-GCM', iv:toB64(iv), wrappedKeyAlgo:'RSA-OAEP', wrappedKey:toB64(wrapped), ciphertext:toB64(ct), filename:file.name, mime:file.type||'application/octet-stream', size:file.size, createdAt:new Date().toISOString() }; downloadJSON(file.name+'.enc.json', pkg); showStatus('#encStatus','Klar: filen √§r krypterad och nedladdad ‚úîÔ∏è','ok'); }); }); }); }).catch(function(e){ showStatus('#encStatus','Fel vid kryptering: '+e.message,'err'); }); }
  function ensureUnlocked(opSel){ if(unlocked && priv.encKey && priv.signKey) return true; showStatus(opSel||'#vaultStatus','√Ötg√§rden kr√§ver uppl√•st session. Skriv l√∂senordet och klicka "L√•s upp".','warn'); return false; }
  function decryptForMe(){ if(!ensureUnlocked('#decStatus')) return; var file=document.getElementById('decFile').files[0]; if(!file) return showStatus('#decStatus','V√§lj en .enc.json att dekryptera.','warn'); file.text().then(function(txt){ try{ var pkg=JSON.parse(txt); if(pkg.type!=='hybrid-enc') throw new Error('Ok√§nt paketformat.'); var wrapped=fromB64(pkg.wrappedKey); var iv=new Uint8Array(fromB64(pkg.iv)); touch(); showStatus('#decStatus','√Öterst√§ller AES‚Äënyckel‚Ä¶'); crypto.subtle.unwrapKey('raw', wrapped, priv.encKey, {name:'RSA-OAEP'}, {name:'AES-GCM', length:256}, true, ['decrypt']).then(function(aesKey){ showStatus('#decStatus','Dekrypterar (AES‚ÄëGCM)‚Ä¶'); crypto.subtle.decrypt({name:'AES-GCM', iv:iv}, aesKey, fromB64(pkg.ciphertext)).then(function(pt){ var outBlob=new Blob([pt], {type: pkg.mime||'application/octet-stream'}); var outName=(pkg.filename||'fil')+'.decrypted'; download(outName, outBlob, outBlob.type); showStatus('#decStatus','Klar: filen √§r dekrypterad ‚úîÔ∏è','ok'); }); }); } catch(e){ showStatus('#decStatus','Fel vid dekryptering: '+e.message,'err'); } }).catch(function(e){ showStatus('#decStatus','Fel: '+e.message,'err'); }); }

  // ---- Sign & Verify ----
  function signFile(){ if(!ensureUnlocked('#signStatus')) return; var file=document.getElementById('signFile').files[0]; if(!file) return showStatus('#signStatus','V√§lj en fil att signera.','warn'); showStatus('#signStatus','L√§ser fil‚Ä¶'); file.arrayBuffer().then(function(data){ crypto.subtle.digest('SHA-256', data).then(function(digest){ touch(); showStatus('#signStatus','Signerar (ECDSA P‚Äë256)‚Ä¶'); crypto.subtle.sign({name:'ECDSA', hash:'SHA-256'}, priv.signKey, digest).then(function(sig){ (pubJwk.sign? Promise.resolve(pubJwk.sign) : dbGet('pub.sign.jwk')).then(function(pub){ var sigPkg={ type:'ecdsa-detached-sig', algorithm:'ECDSA-P256-SHA256', file:{ name:file.name, size:file.size, mime:file.type||'application/octet-stream' }, sha256:toHex(digest), signature:toB64(sig), publicKeyJwk: pub, createdAt:new Date().toISOString() }; downloadJSON(file.name+'.sig.json', sigPkg); showStatus('#signStatus','Klar: signatur skapad ‚úîÔ∏è','ok'); }); }); }); }).catch(function(e){ showStatus('#signStatus','Fel vid signering: '+e.message,'err'); }); }
  function verifySig(){ var f=document.getElementById('verifyFile').files[0]; var s=document.getElementById('verifySig').files[0]; if(!f||!s) return showStatus('#verifyStatus','V√§lj b√•de fil och .sig.json.','warn'); Promise.all([f.arrayBuffer(), s.text()]).then(function(arr){ var data=arr[0]; var sigTxt=arr[1]; try{ var sigPkg=JSON.parse(sigTxt); if(sigPkg.type!=='ecdsa-detached-sig') throw new Error('Ok√§nt signaturformat.'); crypto.subtle.digest('SHA-256', data).then(function(digest){ if(toHex(digest)!==sigPkg.sha256) return showStatus('#verifyStatus','Hash mismatch ‚Äì fel fil?','err'); crypto.subtle.importKey('jwk', sigPkg.publicKeyJwk, {name:'ECDSA', namedCurve:'P-256'}, true, ['verify']).then(function(pubKey){ crypto.subtle.verify({name:'ECDSA', hash:'SHA-256'}, pubKey, fromB64(sigPkg.signature), digest).then(function(ok){ showStatus('#verifyStatus', ok? 'Signaturen √§r GILTIG ‚úîÔ∏è' : 'Ogiltig signatur ‚úñÔ∏è', ok? 'ok':'err'); }); }); }); } catch(e){ showStatus('#verifyStatus','Fel vid verifiering: '+e.message,'err'); } }); }

  // ---- Wire up ----
  function on(id, ev, fn){ var el=document.getElementById(id); if(el) el.addEventListener(ev, fn); }
  function wire(){
    on('genKeys','click', generateKeys);
    on('exportPubEnc','click', exportPubEnc);
    on('exportPubSign','click', exportPubSign);
    on('downloadPubEnc','click', function(){ var val=document.getElementById('pubEncOut').value.trim(); if(!val) return showStatus('#keysStatus','Exportera f√∂rst.','warn'); download('public-encryption-key.pubkey.json', new Blob([val],{type:'application/json'}), 'application/json'); });
    on('downloadPubSign','click', function(){ var val=document.getElementById('pubSignOut').value.trim(); if(!val) return showStatus('#keysStatus','Exportera f√∂rst.','warn'); download('public-signing-key.pubsigkey.json', new Blob([val],{type:'application/json'}), 'application/json'); });
    on('importTheirPub','click', importRecipientFromText);
    on('theirPubFile','change', theirPubFileChanged);
    on('doEncrypt','click', encryptForRecipient);
    on('doDecrypt','click', decryptForMe);
    on('doSign','click', signFile);
    on('doVerify','click', verifySig);
    on('setPassBtn','click', setPassword);
    on('unlockBtn','click', function(){ var sel=document.getElementById('autoLockMins'); autoLockMinutes = sel? parseInt(sel.value,10):5; unlockNow(); });
    on('lockNowBtn','click', lockNow);
    on('wipeBtn','click', wipeAll);
    on('exportVaultBtn','click', exportVault);
    on('importVaultFile','change', importVaultFromFile);
    on('regWebAuthnBtn','click', registerWebAuthn);
    on('testWebAuthnBtn','click', testWebAuthn);
    on('removeWebAuthnBtn','click', removeWebAuthn);
    on('requireWebAuthn','change', toggleRequireWebAuthn);

    document.addEventListener('click', touch); document.addEventListener('keydown', touch);
  }

  // ---- Init ----
  function init(){
    ensureEnv();
    Promise.all([ dbGet('pub.enc.jwk'), dbGet('pub.sign.jwk'), dbGet('webauthn.cred'), dbGet('webauthn.required'), dbGet('vault') ]).then(function(arr){
      pubJwk.enc = arr[0]; pubJwk.sign = arr[1]; webauthnCred = arr[2]; webauthnRequired = (arr[3]===true); var hasVault=!!arr[4]; setLockState(); updateWebAuthnState(); showStatus('#keysStatus','Nyckelstatus:
- Vault: '+(hasVault?'finns ‚úîÔ∏è':'saknas')+'
- Publika nycklar: '+((pubJwk.enc&&pubJwk.sign)?'finns ‚úîÔ∏è':'saknas')); wire();
    });
  }

  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
})();
</script>
</body>
</html>
