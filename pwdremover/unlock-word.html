<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Extrahera PDF ur Word (.docx) – klient‑side (Agile/2010+)</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827ee; --accent:#22d3ee; --muted:#94a3b8; --text:#e5e7eb; --error:#f87171; --ok:#86efac; }
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 20% 10%,#1f2937 0,#0b1220 45%,#0a0f1c 100%);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;display:grid;place-items:start center;padding:40px 16px}
    .app{width:min(980px,100%);background:var(--panel);border:1px solid #1f2937;border-radius:24px;box-shadow:0 10px 40px rgba(0,0,0,.35);overflow:hidden}
    header{padding:28px 32px 16px;border-bottom:1px solid #1f2937}
    header h1{margin:0 0 8px;font-size:20px}
    header p{margin:0;color:var(--muted);font-size:14px}
    .content{padding:24px 32px;display:grid;gap:18px}
    .grid{display:grid;gap:14px;grid-template-columns:1fr}
    @media (min-width:900px){.grid{grid-template-columns:1fr 1fr}}
    .drop{border:1px dashed #334155;border-radius:16px;padding:24px;text-align:center;background:#0b1220cc;transition:.2s}
    .drop.dragover{border-color:var(--accent);background:#0b1220f0}
    .drop input{display:none}
    .drop label{display:inline-block;padding:10px 14px;border-radius:12px;background:#0b1220;border:1px solid #1f2937;cursor:pointer}
    .controls{display:grid;gap:12px;grid-template-columns:1fr auto;align-items:end}
    .controls input{background:#0b1220;border:1px solid #1f2937;color:var(--text);border-radius:12px;padding:12px 14px;width:100%}
    .btn{background:linear-gradient(135deg,#06b6d4,#22d3ee);color:#002b36;font-weight:700;border:none;border-radius:12px;padding:12px 16px;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .hidden{display:none!important}
    .note{font-size:13px;color:var(--muted)}
    .status{padding:12px 14px;border-radius:12px;background:#0b1220;border:1px solid #1f2937;font-size:14px}
    .status.ok{border-color:#14532d;color:var(--ok)}
    .status.err{border-color:#7f1d1d;color:var(--error)}
    .results{display:grid;gap:10px}
    .card{display:grid;gap:8px;grid-template-columns:1fr auto;align-items:center;background:#0b1220;border:1px solid #1f2937;border-radius:12px;padding:12px 14px}
    .chip{font-size:12px;color:#a1a1aa;border:1px solid #27272a;padding:4px 8px;border-radius:999px}
    .download{text-decoration:none;padding:8px 12px;border-radius:10px;background:#1f2937;color:var(--text);border:1px solid #334155}
    details{background:#0b1220;border:1px solid #1f2937;border-radius:12px;padding:12px 14px}
    summary{cursor:pointer;color:var(--accent)}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cfb@1.2.2/cfb.min.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <h1>Extrahera inbäddade PDF:er från Word</h1>
      <p>Ren klient‑side. Stöd för <strong>Agile‑krypterade .docx (Office 2010+)</strong>. Äldre RC4/CryptoAPI och IRM stöds inte.</p>
    </header>

    <div class="content">
      <div class="grid">
        <div class="drop" id="drop">
          <input type="file" id="file" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/octet-stream" />
          <p>Släpp din <strong>.docx</strong> här eller</p>
          <label for="file">välj fil…</label>
          <p class="note">Kräver https/localhost för WebCrypto.</p>
        </div>
        <div class="controls">
          <div>
            <label for="password" class="note">Lösenord</label>
            <input type="password" id="password" placeholder="Om filen är krypterad" />
          </div>
          <button class="btn" id="go" disabled>Analysera & extrahera</button>
        </div>
      </div>

      <details id="diag" class="hidden"><summary>Diagnostik</summary><pre id="diagpre" class="note"></pre></details>
      <div id="status" class="status hidden"></div>
      <div class="results" id="results"></div>
    </div>
  </div>

<script>
(function(){
  // --- Safe helpers (avoid syntax that could trip older parsers) ---
  var drop = document.getElementById('drop');
  var fileInput = document.getElementById('file');
  var goBtn = document.getElementById('go');
  var statusEl = document.getElementById('status');
  var resultsEl = document.getElementById('results');
  var passEl = document.getElementById('password');
  var diag = document.getElementById('diag');
  var diagpre = document.getElementById('diagpre');
  var pickedFile = null;

  function setStatus(msg, type){
    if (!statusEl) return;
    statusEl.className = 'status';
    if (!msg){ statusEl.classList.add('hidden'); return; }
    statusEl.classList.remove('hidden');
    statusEl.textContent = msg;
    if (type === 'ok') statusEl.classList.add('ok');
    if (type === 'err') statusEl.classList.add('err');
  }
  function humanSize(n){
    if (n < 1024) return n + ' B';
    if (n < 1024*1024) return (n/1024).toFixed(1) + ' kB';
    if (n < 1024*1024*1024) return (n/1024/1024).toFixed(1) + ' MB';
    return (n/1024/1024/1024).toFixed(1) + ' GB';
  }

  function onFiles(files){
    var f = files && files[0];
    if (!f) return;
    pickedFile = f;
    if (goBtn) goBtn.disabled = false;
    setStatus('Vald fil: ' + f.name + ' (' + humanSize(f.size) + ')');
    resultsEl.innerHTML = '';
  }

  if (fileInput){
    fileInput.addEventListener('change', function(e){ try { onFiles(e.target.files); } catch(err){ setStatus('Fel vid läsning: ' + err, 'err'); } });
  }
  if (drop){
    ['dragenter','dragover'].forEach(function(ev){ drop.addEventListener(ev, function(e){ e.preventDefault(); e.stopPropagation(); drop.classList.add('dragover'); }); });
    ['dragleave','drop'].forEach(function(ev){ drop.addEventListener(ev, function(e){ e.preventDefault(); e.stopPropagation(); drop.classList.remove('dragover'); }); });
    drop.addEventListener('drop', function(e){ try{ onFiles(e.dataTransfer.files);}catch(err){ setStatus('Fel vid drop: ' + err, 'err'); } });
  }

  function readAsArrayBuffer(file){
    return new Promise(function(res, rej){
      var fr = new FileReader();
      fr.onload = function(){ res(fr.result); };
      fr.onerror = function(){ rej(fr.error || 'filfel'); };
      fr.readAsArrayBuffer(file);
    });
  }
  function u8equals(a, b){ if (a.length !== b.length) return false; for (var i=0;i<a.length;i++){ if (a[i]!==b[i]) return false; } return true; }
  function isZip(u8){ var sigs=[[0x50,0x4B,0x03,0x04],[0x50,0x4B,0x05,0x06],[0x50,0x4B,0x07,0x08]]; for (var i=0;i<sigs.length;i++){ var s=sigs[i]; var ok=true; for (var j=0;j<4;j++){ if (u8[j]!==s[j]) {ok=false; break;} } if (ok) return true; } return false; }
  function isCFB(u8){ var sig=[0xD0,0xCF,0x11,0xE0,0xA1,0xB1,0x1A,0xE1]; for (var i=0;i<8;i++){ if (u8[i]!==sig[i]) return false; } return true; }

  // --- WebCrypto helpers ---
  var subtle = (crypto && crypto.subtle) ? crypto.subtle : null;
  if (!subtle){ setStatus('WebCrypto saknas i denna miljö. Testa senaste Chrome/Edge/Firefox/Safari över https.', 'err'); }
  var asciiDecoder = new TextDecoder('ascii');
  var utf8Decoder = new TextDecoder('utf-8');
  function encU16(str){ var buf=new Uint8Array(str.length*2); for (var i=0;i<str.length;i++){ var c=str.charCodeAt(i); buf[i*2]=c&0xFF; buf[i*2+1]=c>>>8; } return buf; }
  function b64ToU8(b64){ var bin=atob(b64); var u8=new Uint8Array(bin.length); for (var i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return u8; }
  function le32(i){ return new Uint8Array([i & 0xFF,(i>>>8)&0xFF,(i>>>16)&0xFF,(i>>>24)&0xFF]); }
  function concat(){ var total=0; for (var i=0;i<arguments.length;i++) total+=arguments[i].length; var out=new Uint8Array(total), off=0; for (var j=0;j<arguments.length;j++){ out.set(arguments[j], off); off+=arguments[j].length; } return out; }
  function digest(name, dataU8){ return subtle.digest(name, dataU8).then(function(buf){ return new Uint8Array(buf); }); }
  function aesCbcDecryptRaw(keyBytes, iv, data){
    return subtle.importKey('raw', keyBytes, {name:'AES-CBC'}, false, ['decrypt']).then(function(key){
      return subtle.decrypt({name:'AES-CBC', iv:iv}, key, data);
    }).then(function(res){ return new Uint8Array(res); });
  }

  function parseAgileXMLFromEncryptionInfo(u8){
    var s = asciiDecoder.decode(u8);
    var ix = s.indexOf('<encryption');
    if (ix === -1) return null;
    var xml = s.slice(ix);
    var doc = new DOMParser().parseFromString(xml, 'application/xml');
    function get(el, attr){ return el ? el.getAttribute(attr) : null; }
    var keyData = doc.querySelector('keyData');
    var ke = doc.querySelector('keyEncryptors > keyEncryptor[uri][uri*="password"] > encryptedKey');
    if (!keyData || !ke) return null;
    return {
      keyData: {
        cipherAlgorithm: get(keyData, 'cipherAlgorithm')||'AES',
        cipherChaining: get(keyData, 'cipherChaining')||'ChainingModeCBC',
        hashAlgorithm: get(keyData, 'hashAlgorithm')||'SHA1',
        saltValue: get(keyData, 'saltValue')||'',
        saltSize: +(get(keyData, 'saltSize')||'16'),
        blockSize: +(get(keyData, 'blockSize')||'16'),
        keyBits: +(get(keyData, 'keyBits')||'256')
      },
      encKey: {
        spinCount: +(get(ke,'spinCount')||'100000'),
        saltValue: get(ke,'saltValue')||'',
        hashAlgorithm: get(ke,'hashAlgorithm')||'SHA1',
        cipherAlgorithm: get(ke,'cipherAlgorithm')||'AES',
        cipherChaining: get(ke,'cipherChaining')||'ChainingModeCBC',
        keyBits: +(get(ke,'keyBits')||'256'),
        encryptedKeyValue: (ke.textContent||'').trim()
      }
    };
  }
  function normalizeHashName(n){ n = (n||'').toUpperCase(); if (n.indexOf('512')!==-1) return 'SHA-512'; if (n.indexOf('384')!==-1) return 'SHA-384'; if (n.indexOf('256')!==-1) return 'SHA-256'; return 'SHA-1'; }
  function deriveAgilePasswordKey(password, salt, spinCount, hashName, keyBytesLen){
    var hashAlgo = normalizeHashName(hashName);
    var pwU16 = encU16(password);
    return digest(hashAlgo, concat(salt, pwU16)).then(function(h){
      var i=0;
      function loop(){
        if (i>=spinCount) return Promise.resolve(h);
        var next = concat(h, le32(i)); i++;
        return digest(hashAlgo, next).then(function(h2){ h = h2; return loop(); });
      }
      return loop();
    }).then(function(h){
      var out = new Uint8Array(keyBytesLen); var off=0, block=0;
      function fill(){
        if (off>=keyBytesLen) return out;
        return digest(hashAlgo, concat(h, le32(block++))).then(function(kb){
          var take = Math.min(kb.length, keyBytesLen - off);
          out.set(kb.subarray(0,take), off); off += take; return fill();
        });
      }
      return fill();
    });
  }

  function tryAgileDecrypt(cfb, password){
    var encInfoEntry = null, encPkgEntry = null;
    for (var i=0;i<cfb.FileIndex.length;i++){
      var e = cfb.FileIndex[i];
      if (e.name === 'EncryptionInfo') encInfoEntry = e;
      if (e.name === 'EncryptedPackage') encPkgEntry = e;
    }
    if (!encInfoEntry || !encPkgEntry) return Promise.reject(new Error('Saknar EncryptionInfo/EncryptedPackage'));
    var infoU8 = new Uint8Array(encInfoEntry.content);
    var agile = parseAgileXMLFromEncryptionInfo(infoU8);
    if (!agile) return Promise.reject(new Error('Inte Agile‑kryptering (eller XML kunde inte läsas).'));

    // Visa diagnostik
    try { diag.classList.remove('hidden'); diagpre.textContent = JSON.stringify({ keyData: agile.keyData, encKey: { spinCount: agile.encKey.spinCount, hashAlgorithm: agile.encKey.hashAlgorithm, keyBits: agile.encKey.keyBits, hasEncryptedKeyValue: !!agile.encKey.encryptedKeyValue } }, null, 2); } catch(e){}

    var kdSalt = b64ToU8(agile.keyData.saltValue);
    var ekSalt = b64ToU8(agile.encKey.saltValue);
    var keyLen = (agile.encKey.keyBits||256)/8;

    return deriveAgilePasswordKey(password, ekSalt, agile.encKey.spinCount, agile.encKey.hashAlgorithm, keyLen).then(function(pwdKey){
      function decryptKey(iv){
        if (!agile.encKey.encryptedKeyValue) return Promise.resolve(null);
        var encKeyBytes = b64ToU8(agile.encKey.encryptedKeyValue);
        return aesCbcDecryptRaw(pwdKey, iv.subarray(0,16), encKeyBytes.buffer).then(function(dec){ return new Uint8Array(dec).subarray(0, keyLen); });
      }
      return decryptKey(ekSalt).catch(function(){ return decryptKey(kdSalt); }).then(function(packageKey){
        if (!packageKey) packageKey = pwdKey; // Standard‑profil
        var pkgCipher = new Uint8Array(encPkgEntry.content);
        return aesCbcDecryptRaw(packageKey, kdSalt.subarray(0,16), pkgCipher.buffer);
      });
    }).then(function(plain){
      // leta ZIP
      var start=-1; for (var i=0;i+4<=plain.length;i++){ if (plain[i]===0x50 && plain[i+1]===0x4B && plain[i+2]===0x03 && plain[i+3]===0x04){ start=i; break; } }
      if (start===-1) throw new Error('Kunde inte hitta ZIP‑signatur efter dekryptering (fel lösenord/algoritm).');
      return plain.subarray(start);
    });
  }

  function addResult(name, bytes){
    var url = URL.createObjectURL(new Blob([bytes], { type: 'application/pdf' }));
    var card = document.createElement('div'); card.className='card';
    var left = document.createElement('div'); var right = document.createElement('div');
    var title = document.createElement('div'); title.innerHTML = '<strong>'+name+'</strong>';
    var meta = document.createElement('div'); meta.innerHTML = '<span class="chip">'+humanSize(bytes.length)+'</span>';
    left.appendChild(title); left.appendChild(meta);
    var a = document.createElement('a'); a.href=url; a.download = name.endsWith('.pdf')?name:(name+'.pdf'); a.textContent='Ladda ner'; a.className='download';
    right.appendChild(a); card.appendChild(left); card.appendChild(right); resultsEl.appendChild(card);
  }

  function extractFromDocxZip(u8){
    return JSZip.loadAsync(u8).then(function(zip){
      var files = Object.values(zip.files);
      var embeddings = files.filter(function(f){ return f.name.indexOf('word/embeddings/')===0 && !f.dir; });
      var tasks = [];
      // direkt PDF
      embeddings.filter(function(f){ return /\.pdf$/i.test(f.name); }).forEach(function(f){
        tasks.push(f.async('arraybuffer').then(function(ab){ var bytes=new Uint8Array(ab); if (bytes[0]===0x25&&bytes[1]===0x50&&bytes[2]===0x44&&bytes[3]===0x46) addResult(f.name.split('/').pop(), bytes); }));
      });
      // OLE‑bin
      embeddings.filter(function(f){ return /\.bin$/i.test(f.name); }).forEach(function(f){
        tasks.push(f.async('arraybuffer').then(function(ab){
          try {
            var cfb = CFB.read(new Uint8Array(ab), { type:'array' });
            var entry=null; for (var i=0;i<cfb.FileIndex.length;i++){ var en=cfb.FileIndex[i]; if (/(Ole10Native|Package|CONTENTS)$/.test(en.name)){ entry=en; break; } }
            if (entry && entry.content){
              var bytes=new Uint8Array(entry.content); var i=0; for (; i+4<=bytes.length; i++){ if (bytes[i]===0x25&&bytes[i+1]===0x50&&bytes[i+2]===0x44&&bytes[i+3]===0x46) break; }
              var pdf=bytes.subarray(i); if (pdf.length>=4 && pdf[0]===0x25&&pdf[1]===0x50&&pdf[2]===0x44&&pdf[3]===0x46) addResult((f.name.split('/').pop()||'inbäddad')+'.pdf', pdf);
            }
          } catch(e){ console.warn('OLE‑tolkning misslyckades', f.name, e); }
        }));
      });
      return Promise.all(tasks).then(function(){ if (!resultsEl.children.length) setStatus('Hittade inga inbäddade PDF:er i dokumentet.', 'err'); else setStatus('Klart! Hittade '+resultsEl.children.length+' PDF‑fil(er).', 'ok'); });
    });
  }

  function onGo(){
    resultsEl.innerHTML = '';
    setStatus('Läser fil …');
    if (!pickedFile){ setStatus('Ingen fil vald.', 'err'); return; }
    readAsArrayBuffer(pickedFile).then(function(ab){
      var u8 = new Uint8Array(ab);
      var password = passEl && passEl.value ? passEl.value : '';
      if (isZip(u8)){
        setStatus('Upptäckte okrypterad .docx. Extraherar …');
        return extractFromDocxZip(u8);
      }
      if (!isCFB(u8)) throw new Error('Okänt filformat – förväntade .docx (ZIP) eller krypterad .docx (CFB).');
      if (!password) { setStatus('Detta ser ut som en krypterad .docx. Ange lösenord.', 'err'); return; }
      setStatus('Dekrypterar (Agile/2010+) …');
      var cfb = CFB.read(u8, { type:'array' });
      return tryAgileDecrypt(cfb, password).then(function(decZip){ setStatus('Dekryptering klar. Extraherar …'); return extractFromDocxZip(decZip); });
    }).catch(function(err){ console.error(err); setStatus('Fel: '+(err && err.message? err.message : String(err)), 'err'); });
  }

  if (goBtn){ goBtn.addEventListener('click', onGo); }
})();
</script>
</body>
</html>
